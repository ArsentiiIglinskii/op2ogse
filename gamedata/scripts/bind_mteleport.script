-- -*- mode: lua; coding: windows-1251-dos -*-
-- ************************************************
-- **                    Imp                     **
-- **       Биндер самодельных телепортов        **
-- ** Поддерживает работу самопальных телепортов **
-- **    Proper70 доработано для поддержания     **
-- **    функций рестриктора и выдачи поршней,   **
-- **    а также поддержки формы телепорта box   **
-- ************************************************

-- Proper70 в конфиг добавлены параметры для поддержания функций
-- рестриктора и выдачи поршней:
--
-- info = vzn_temp1 -- есди задано - выдается этот поршень
--
-- func = kostya_dialog.give_ammo(1)-- если задано - вызывается эта
-- функция с указанными параметрами, все писать без пробелов.
--
-- для создания телепорта в форме box в конфиге можно задавать 3 параметра:
-- x_radius, y_radius, z_radius. z_radius = высота.


function abs_comp( a, b )
  -- Служебная функция вычисления разности
  if( a < b) then
    return ( b - a )
  else
    return ( a - b )
  end
end


function teleportate( x, y, z )
  -- Функция телепортации
  local a = vector()
  -- Задаем координаты
  a.x = x
  a.y = y
  a.z = z
  -- Сама телепортация
  db.actor:set_actor_position( a )
end


function bind( obj )
  obj:bind_object( restrictor_teleport( obj ) )
end


class "restrictor_teleport" ( object_binder )
function restrictor_teleport:__init( obj ) super( obj )
  self.sm = ogse_signals.get_mgr()
end


function restrictor_teleport:net_spawn( data )
  if not self.teleport then return true end
  -- Заполним таблицу параметров
  self.parametrs = {}
  if sys_ini:line_exist( self.section, "radius" ) then
    self.parametrs.x_radius = get_float( self.section, "radius" )
    self.parametrs.y_radius = get_float( self.section, "radius" )
  else
    self.parametrs.x_radius = 2 -- Дефолтный радиус по xy
    self.parametrs.y_radius = 2 -- Дефолтный радиус по xy
  end
  if sys_ini:line_exist( self.section, "z_radius" ) then
    self.parametrs.z_radius = get_float( self.section, "z_radius" )
  else
    -- если радиус высоты не задан то задаем равным радиусу xy
    self.parametrs.z_radius = self.parametrs.x_radius
  end
  --  параметры box
  if sys_ini:line_exist( self.section, "x_radius" ) then
    self.parametrs.x_radius = get_float( self.section, "x_radius" )
  end
  if sys_ini:line_exist( self.section, "y_radius" ) then
    self.parametrs.y_radius = get_float( self.section, "y_radius" )
  end
  -- Запомним позицию что-бы каждый раз не считать
  local s_obj = alife():object( self.object:id() )
  self.parametrs.x = s_obj.position.x
  self.parametrs.y = s_obj.position.y
  self.parametrs.z = s_obj.position.z
  -- Запомним координаты куда телепортимся
  local rnd = get_u32( self.section, "poz_rnd" )
  local s   = poz_rnd and math.random( rnd ) or ""
  self.parametrs.poz_x  = get_float( self.section, "poz_x" .. s )
  self.parametrs.poz_y  = get_float( self.section, "poz_y" .. s )
  self.parametrs.poz_z  = get_float( self.section, "poz_z" .. s )
  self.parametrs.rotate = get_float( self.section, "rotate" )
  -- Функции рестриктора
  -- выдать поршень
  self.parametrs.info = get_string( self.section, "info" )
  -- выполнить функцию
  self.parametrs.func = get_string( self.section, "func" )
  self.subscribed = {
    [ "signal" ] = "on_update",
    [ "fun"    ] = self.actor_update,
    [ "self"   ] = self,
  }
  self.sm:subscribe( self.subscribed )
  return true
end


function restrictor_teleport:net_destroy()
  -- Удаляем наш телепорт
  if self.subscribed then
    self.sm:unsubscribe( self.subscribed )
    self.subscribed = nil
  end
  self.parametrs = nil
  object_binder.net_destroy( self )
end


function restrictor_teleport:reload( section )
  self.section = section
  -- Если это телепорт то
  if sys_ini:line_exist( self.section, "teleport" ) then
    self.teleport = true
  end
end


function restrictor_teleport:actor_update( delta )
  local s = self.parametrs
  if s.teleporte then
    -- Телепорт запущен
    teleportate( s.poz_x, s.poz_y, s.poz_z )
    if s.rotate then
      db.actor:set_actor_direction( s.rotate )
    end
    -- выполняем функции рестриктора
    if s.info then
      -- выдаем поршень
      db.actor:give_info_portion( s.info )
    end
    if s.func then
      -- выполняем функцию
      local f, err = loadstring( s.func )
      ASSERT( f, err )
      f()
    end
    s.teleporte = false
    db.actor:give_info_portion( "teleport_finished" )
  else
    -- Проверим не забрел ли актор в наш телепорт
    local acter_poz = db.actor:position()
    if
      abs_comp( s.x, acter_poz.x ) < s.x_radius
      and abs_comp( s.z, acter_poz.z ) < s.y_radius
      and abs_comp( s.y, acter_poz.y ) < s.z_radius
    then
      -- Актер в зоне действия телепорта, запустим телепорт
      db.actor:give_info_portion( "teleport_started" )
      s.teleporte = true
      self.sm:reschedule( 1500 )
      -- Запускаем спецэфекты телепортации
      level.add_pp_effector( "teleport.ppe", 2006, false )
      -- Звуковое сопровождение
      local snd_obj = xr_sound.get_safe_sound_object(
        [[anomaly\teleport_work_1]]
      )
      snd_obj:play_no_feedback( db.actor, sound_object.s2d, 0, vector(), 1.0 )
      return
    end
  end
  local dist = self.object:position():distance_to( db.actor:position() )
  self.sm:reschedule(
    ( dist < 25 and 200 ) or ( dist < 100 and 1000 )
    or math.random( 5000, 6000 )
  )
end
