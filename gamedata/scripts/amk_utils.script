-- -*- mode: lua; coding: windows-1251-dos -*-

-- Callback на смерть монстров
function monster_death( victim, who )
  if string.find( victim:name(), "marsh_controller" ) then
    db.actor:give_info_portion( "marsh_controller_dead" )
  elseif string.find( victim:name(), "rad_red_burer1" ) then
    db.actor:give_info_portion( "rad_red_burer1_dead" )
  elseif string.find( victim:name(), "rad_red_krovosos1" ) then
    db.actor:give_info_portion( "rad_red_krovosos1_dead" )
  elseif string.find( victim:name(), "mil_red_burer1" ) then
    db.actor:give_info_portion( "mil_red_burer1_dead" )
  elseif string.find( victim:name(), "mil_red_krovosos1" ) then
    db.actor:give_info_portion( "mil_red_krovosos1_dead" )
  elseif string.find( victim:name(), "agr_red_burer1" ) then
    db.actor:give_info_portion( "agr_red_burer1_dead" )
  elseif string.find( victim:name(), "agr_red_krovosos1" ) then
    db.actor:give_info_portion( "agr_red_krovosos1_dead" )
  elseif string.find( victim:name(), "val_red_burer1" ) then
    db.actor:give_info_portion( "val_red_burer1_dead" )
  elseif string.find( victim:name(), "val_red_krovosos1" ) then
    db.actor:give_info_portion( "val_red_krovosos1_dead" )
  end
end


-- Callback на смерть непися
function npc_death( victim, who )
  kostya_dialog.stealth_fail_task( victim, who )
end


-- Callback на взятие предмета в инвентарь гг
function actor_item_take( obj )
  inventory_update( obj, 1 )
end


-- Callback на потерю предмета из инвенаря гг
function actor_item_drop( obj )
  inventory_update( obj, -1 )
end


--Кеш текущего состояния инвентаря ГГ (только предметы проверяемые
--функцией inventory_search, их обычно немного)
local InventoryState = {}

-- Проверка на количество предметов в инвентаре гг
function inventory_search( iItemSection, iNeededCount )
  -- Взятие из кеша текущего состояния инвентаря:
  return (
    InventoryState[ iItemSection ]
      and InventoryState[ iItemSection ].cnt >= iNeededCount
  ) or false
end


-- Обработчик появления или исчезновения предмета в инвентаре (нужно
-- обновить кеш):
function inventory_update( iObject, iCountDelta )
  if not iObject then return end
  local vItemSection = iObject:section()
  if not InventoryState[ vItemSection ] then
    InventoryState[ vItemSection ] = {
      [ "cnt" ] = 0,
      [ "obj" ] = {},
    }
  end
  -- Взятие из кеша текущего состояния инвентаря:
  local vCount = InventoryState[ vItemSection ].cnt
  -- Обновление текущего состояния инвентаря в кеше:
  vCount = vCount + iCountDelta
  ASSERT(
    vCount >= 0,
    "negative vCount (%s) for %s, iCountDelta = %s",
    vCount, iObject:name(), iCountDelta
  )
  InventoryState[ vItemSection ].cnt = vCount
  if iCountDelta > 0 then
    InventoryState[ vItemSection ].obj[ iObject:id() ] = iObject
  else
    InventoryState[ vItemSection ].obj[ iObject:id() ] = nil
  end
end


function inventory_iterate_section( sect, f )
  if InventoryState[ sect ] then
    for id, obj in pairs( InventoryState[ sect ].obj ) do
      if f( obj ) then return end
    end
  end
end


function inventory_search_check( item_counts, f )
  local t = {}
  for sect, need_cnt in pairs( item_counts ) do
    if not inventory_search( sect, need_cnt ) then return false end
    local found_cnt = 0
    inventory_iterate_section(
      sect,
      function( obj )
        if ( not f ) or f( obj ) then
          found_cnt = found_cnt + 1
          table.insert( t, obj )
          if found_cnt == need_cnt then return true end
        end
      end
    )
    if found_cnt < need_cnt then return false end
  end
  return true, t
end


function out_items( items )
  local found = {}
  local t     = {}
  for _, sect in ipairs( items ) do
    inventory_iterate_section(
      sect,
      function( obj )
        found[ obj:section() ] = ( found[ obj:section() ] or 0 ) + 1
        table.insert( t, obj )
      end
    )
  end
  for sect, _ in pairs( found ) do
    news_manager.relocate_item( db.actor, "out", sect )
  end
  while table.getn( t ) > 0 do
    ogse.remove_item_from_inventory( table.remove( t ) )
  end
  return found
end


function out_items_number( item_counts )
  local res, t = inventory_search_check( item_counts )
  ASSERT( res, "unexpected result" )
  local items = {}
  for _, obj in ipairs( t ) do
    items[ obj:section() ] = ( items[ obj:section() ] or 0 ) + 1
  end
  for sect, _ in pairs( items ) do
    news_manager.relocate_item( db.actor, "out", sect )
  end
  while table.getn( t ) > 0 do
    ogse.remove_item_from_inventory( table.remove( t ) )
  end
end


function good_items_have_number( item_counts )
  return inventory_search_check(
    item_counts,
    function( obj ) return obj:condition() > 0.95 end
  )
end


function bad_items_have_number( item_counts )
  return inventory_search_check(
    item_counts,
    function( obj ) return obj:condition() <= 0.95 end
  )
end


function out_good_items_number( item_counts )
  local res, t = good_items_have_number( item_counts )
  ASSERT( res, "unexpected result" )
  local items = {}
  for _, obj in ipairs( t ) do
    items[ obj:section() ] = ( items[ obj:section() ] or 0 ) + 1
  end
  for sect, _ in pairs( items ) do
    news_manager.relocate_item( db.actor, "out", sect )
  end
  while table.getn( t ) > 0 do
    ogse.remove_item_from_inventory( table.remove( t ) )
  end
end


function out_bad_items_number( item_counts )
  local res, t = bad_items_have_number( item_counts )
  ASSERT( res, "unexpected result" )
  local items = {}
  for _, obj in ipairs( t ) do
    items[ obj:section() ] = ( items[ obj:section() ] or 0 ) + 1
  end
  for sect, _ in pairs( items ) do
    news_manager.relocate_item( db.actor, "out", sect )
  end
  while table.getn( t ) > 0 do
    ogse.remove_item_from_inventory( table.remove( t ) )
  end
end
