-- -*- mode: lua; coding: windows-1251-dos -*-
--
-- Схема лагерь. Чудак(и) у костра.
-- автор: Диденко Руслан (Stohe)
-- TODO:

function attach( sm )
  sm:subscribe({ signal = "on_monster_death", fun = this.on_death })
  sm:subscribe({ signal = "on_npc_death",     fun = this.on_death })
end


local last_death_t
function on_death( obj, who )
  last_death_t = time_global()
end


kamps           = {}
kamp_stalkers   = {}    -- могут ли сталкеры в лагере юзаться игроком.
-- Объявления итераторов
deadmansids     = {}          -- кто какой труп оттаскивает
deadmansidsuses = {}          -- сколько попыток оттащить было сделано


function printf( ... )
  log2( ... )
end


function get_my_kamp( npc, path )
  if not kamps[ path ] then
    local kamp = CKampManager( path )
    kamps[ path ] = kamp
  end
  return kamps[ path ]
end


class "CKampManager"
function CKampManager:__init( path )
  self.kamp_name    = path
  self.patrol       = patrol( path )
  self.center       = self.patrol:level_vertex_id( 0 )
  self.position     = {
    { dir = vector():set(  1, 0,  0 ) },
    { dir = vector():set(  1, 0,  1 ) },
    { dir = vector():set(  0, 0,  1 ) },
    { dir = vector():set( -1, 0,  1 ) },
    { dir = vector():set( -1, 0,  0 ) },
    { dir = vector():set( -1, 0, -1 ) },
    { dir = vector():set(  0, 0, -1 ) },
    { dir = vector():set(  1, 0, -1 ) },
  }
  self.npc        = {}
  self.population = 0
  self.kamp_state = "idle"
  self.avail_state = xr_kamp_data.avail_state
  self.avail_sound = xr_kamp_data.avail_sound
  self.timeout     = table.clone( xr_kamp_data.timeout )
  self.kamp_states = table.clone( xr_kamp_data.kamp_states )
  self.trans_kamp  = xr_kamp_data.trans_kamp
  -- Хранилище для режиссера лагеря. Режиссерем является сталкер,
  -- затеявший необычное поведение.
  self.director    = nil
  self:parse_patrol()
end


function CKampManager:parse_patrol()
  -- Где то здесь распарсим патрульный путь и проапдейтим вектор позиций.
  -- 0 вершина - центр лагеря.
  -- 1 флаг - сектор занят, в поинте можно сидеть.
  -- 2 флаг - сектор занят, в поинте нельзя сидеть.
  for k = 1, self.patrol:count() - 1 do
    -- если есть 1 или 2 флажок - отметить сектор как занятый
    if self.patrol:flag( k, 1 ) or self.patrol:flag( k, 2 ) then
      -- отметить сектор как занятый
      for key, value in pairs( self.position ) do
        local pos = level.vertex_position( self.patrol:level_vertex_id( k ) )
        local dir = vector():sub( pos, level.vertex_position( self.center ) )
        if value.dir then
          local yaw = yaw_degree( dir, value.dir )
          if yaw <= 23 then
            value.used = -1
            break
          end
        end
      end
    end
    -- если есть 1 флажок - создать место для сидения в точке пути
    if self.patrol:flag( k, 1 ) then
      -- создать точку для сидения
      table.insert(
        self.position, { vertex = self.patrol:level_vertex_id( k ) }
      )
    end
  end
end


function CKampManager:selectPosition( npc_id, bind )
  -- пытаемся разместить в заданном в логике месте. А если занято, то как обычно
  if bind and self.position[ bind ] and self.position[ bind ].used == nil then
    self.position[ bind ].used = npc_id
    self.npc[ npc_id ].position = bind
    return
  end
  -- создаем список доступных позиций
  local free = {}
  for k, v in pairs( self.position ) do
    if v.used == nil then
      table.insert( free, k )
    end
  end
  -- затем из доступных позиций выбрать рандомно одну.
  if table.getn( free ) > 0 then
    local rr = free[ math.random( table.getn( free ) ) ]
    self.position[ rr ].used    = npc_id
    self.npc[ npc_id ].position = rr
  end
end


function CKampManager:getDestVertex( npc_id, radius )
  if npc_id == nil then return nil end
  if self.npc[ npc_id ] == nil then return nil end
  ASSERT( self.npc[ npc_id ].position, "get dest Vertex: nil [%s]", npc_id )
  local position = self.position[ self.npc[ npc_id ].position ]
  if position.vertex ~= nil then
    return position.vertex
  end
  -- высчитываем вертех по направлению
  local pp = level.vertex_in_direction( self.center, position.dir, radius )
  pp = level.vertex_in_direction(
    pp, vector():set( math.random( -1,1 ), 0, math.random( -1, 1 ) ),
    math.random( 0, 0.5 )
  )
  return pp
end


function CKampManager:proceedState( npc )
  -- Проверка на таймаут
  local npc_id = npc:id()
  if self.npc[ npc_id ] == nil then return end
  local active_sound_count = npc:active_sound_count()
  if self.npc[ npc_id ].need_sound_begin == true then
    if active_sound_count == 0 then
      return
    else
      self.npc[ npc_id ].need_sound_begin = false
    end
  end
  if self.begin ~= nil and
    time_global() - self.begin < self.timeout[ self.kamp_state ].min
  then
    return
  end

  -- Если режиссер не закончил говорить - ждем конца фразы.
  if active_sound_count > 0 then
    return
  end

  -- В случае с историей переход обрабатывается отдельно
  if self.kamp_state == "post_story" then
    if self.story_last < self.story_max - 1 then
      self.npc[ npc_id ].begin            = nil
      self.npc[ npc_id ].need_sound_begin = true
      self.director   = npc_id
      self.kamp_state = "story"
      self.begin      = time_global()
      for kk, vv in pairs( self.npc ) do
        vv.new = true
      end
      return
    else
      self.selected_story = nil
    end
  end
  -- Определяются допустимые в данный момент переходы.
  local temp    = {}
  local max_rnd = 0
  for k, v in pairs( self.trans_kamp[ self.kamp_state ] ) do
    -- Определяются допустимые состояния для лагеря.
    if self.kamp_states[ k ] == true then
      temp[ k ] = v
      max_rnd   = max_rnd + v
    end
  end
  -- Осуществляется рандомный взвешенный переход.
  if max_rnd == 0 then
    -- Если переходить некуда - переходим в айдл
    temp.idle = 100
    max_rnd   = 100
  end
  local p = math.random( 0, max_rnd )
  for k, v in pairs( temp ) do
    p = p - v
    if p <= 0 then
      if k == "idle" then
        self.director = nil
        if self.kamp_state ~= "idle" then
          self.npc[ npc_id ].begin = nil
        end
      else
        self.npc[ npc_id ].begin = nil
        if self.timeout[ k ].soundstart == true then
          self.npc[ npc_id ].need_sound_begin = true
        end
        self.director = npc_id
        self.censor   = nil
      end
      self.kamp_state = k
      self.begin      = time_global()
      -- Меняем таймаут для истории
      if k == "post_story" then
        local dep = sound_theme_data.theme[ self.selected_story ].depence[ self.story_last ]
        if dep and dep.min and dep.max then
          self.timeout[ "post_story" ].min = math.random( dep.min, dep.max ) * 1000
        end
      end
      for kk, vv in pairs( self.npc ) do
        vv.new = true
      end
      return
    end
  end
end


function CKampManager:proceedRole( npc, director )
  -- Определить список доступных анимаций по состоянию лагеря.
  -- определить список доступных анимаций по наличию предметов
  -- выбрать одну из них (то же самое со звуком).
  local states = 0
  local sound  = ""
  local state  = ""
  local npc_id = npc:id()
  if self.npc[ npc_id ] == nil then return nil, nil end
  if
    self.npc[ npc_id ].begin == nil
    or time_global() - self.npc[ npc_id ].begin >= self.npc[ npc_id ].state_idle
  then
    if director then
      states = self.avail_state[ self.kamp_state ].directed
      sound  = self.avail_sound[ self.kamp_state ].directed
    else
      states = self.avail_state[ self.kamp_state ].undirected
      sound  = self.avail_sound[ self.kamp_state ].undirected
    end
    -- Выбирать новое состояние только раз в какое то время.
    local temp = {}
    for k, v in pairs( states ) do
      if self.npc[ npc_id ].states[ v ] == true then
        table.insert( temp, v )
      end
    end

    -- Если мы решили говорить историю, надо выбрать какую именно говорить.
    if
      sound == "play_story" and self.selected_story == nil
      and db.story_by_id[ npc_id ] ~= nil
    then
      local story_num = table.getn( db.story_by_id[ npc_id ] )
      if story_num > 0 then
        self.selected_story = db.story_by_id[ npc_id ][ math.random( story_num ) ]
      end
    end
    if table.getn( temp ) > 0 then
      state = temp[ math.random( table.getn( temp ) ) ]
      self.npc[ npc_id ].begin          = time_global()
      self.npc[ npc_id ].state_selected = state
      self.npc[ npc_id ].state_idle     = math.random( 15000,20000 )
    else
      state = self.npc[ npc_id ].state_selected
    end
  else
    if director then
      sound = self.avail_sound[ self.kamp_state ].directed
    else
      sound = self.avail_sound[ self.kamp_state ].undirected
    end
    state = self.npc[ npc_id ].state_selected
  end
  return state, sound
end


function CKampManager:updateNpc( npc )
  -- Проверка что сталкер может делать, а что нет.
  self:checkNpcAbility( npc )
  -- Просим лагерь выбрать текущее состояние. Менять состояние лагеря
  -- имеет право только режиссер.
  local npc_id = npc:id()
  if self.npc[ npc_id ] == nil then return nil, nil, nil end
  local director = ( self.director == nil or self.director == npc_id )
    and npc_id ~= self.forbiddendirector
  if director then
    self:proceedState( npc )
  end
  -- Говорим чудаку выбрать себе состояние для текущего состояния лагеря.
  local state, sound = self:proceedRole( npc, director )

  local substate
  if state == "wait_harmonica" then
    if sound == "pre_harmonica" and self.npc[ npc_id ].new == true then
      xr_sound.set_sound_play( npc, "intro_music", math.random( 2000,3000 ) )
      self.npc[ npc_id ].new = false
    end
    state = "harmonica"
    kamp_stalkers[ npc_id ] = false
  elseif state == "play_harmonica" then
    state    = "harmonica"
    substate = 1
    kamp_stalkers[ npc_id ] = false
  elseif state == "wait_guitar" then
    if sound == "pre_guitar" and self.npc[ npc_id ].new == true then
      xr_sound.set_sound_play( npc, "intro_music", math.random( 2000,3000 ) )
      self.npc[ npc_id ].new = false
    end
    state = "guitar"
    kamp_stalkers[ npc_id ] = false
  elseif state == "play_guitar" then
    state    = "guitar"
    substate = 1
    kamp_stalkers[ npc_id ] = false
  elseif state == "wait_balalaika" then
    if sound == "pre_balalaika" and self.npc[ npc_id ].new == true then
      xr_sound.set_sound_play( npc, "intro_music", math.random( 2000,3000 ) )
      self.npc[ npc_id ].new = false
    end
    state = "balalaika"
    kamp_stalkers[ npc_id ] = false
  elseif state == "play_balalaika" then
    state    = "balalaika"
    substate = 1
    kamp_stalkers[ npc_id ] = false
  elseif state == "declarate" then
    if self.npc[ npc_id ].new == true then
      if sound == "pre_joke" then
        xr_sound.set_sound_play( npc, "intro_joke", math.random( 2000,3000 ) )
      elseif sound == "play_joke" then
        xr_sound.set_sound_play( npc, "joke", math.random( 2000, 3000 ) )
      elseif sound == "play_story" then
        xr_sound.set_sound_play( npc, self.selected_story )
        self.story_last, self.story_max = xr_sound.get_last_IDS(
          npc, self.selected_story
        )
        if self.story_last == nil then
          self.story_last = 0
          self.story_max  = 1
          xr_sound.set_sound_play( npc, "threat_back", math.random( 1000,2000 ) )
          --- dirty hack
          self.kamp_state        = "idle"
          self.forbiddendirector = self.director
          self.director          = nil
        end
      end
      self.npc[ npc_id ].new = false
    end
    if npc:character_community() == "monolith" then
      local t = math.mod( npc_id, 2 )
      if t == 0 then
        state = "trans_0"
      else
        state = "trans_1"
      end
    elseif npc:character_community() == "zombied" then
      state = "trans_zombied"
    else
      local t = math.mod( npc_id, 3 )
      if t == 0 then
        state = "sit"
      elseif t == 1 then
        state = "sit_ass"
      else
        state = "sit_knee"
      end
    end
    kamp_stalkers[ npc_id ] = false
  elseif state == "trans" then
    if npc:character_community() == "monolith" then
      local t = math.mod( npc_id, 2 )
      if t == 0 then
        state = "trans_0"
      else
        state = "trans_1"
      end
    elseif npc:character_community() == "zombied" then
      state = "trans_zombied"
    end
    kamp_stalkers[ npc_id ] = false
  else
    kamp_stalkers[ npc_id ] = true
  end
  -- Выбор реальных звуков
  if sound == "idle" then
    sound = "weather, state"
  elseif sound == "reac_guitar" then
    sound = "reac_music"
  elseif sound == "reac_balalaika" then
    sound = "reac_music"
  elseif sound == "reac_harmonica" then
    sound = "reac_music"
  elseif sound == "reac_joke" then
    sound = ""
    if self.npc[ npc_id ].new == true then
      if self.censor == nil then
        xr_sound.set_sound_play( npc, "reac_joke", math.random( 2000,3000 ) )
        self.censor = npc_id
      else
        xr_sound.set_sound_play(
          npc, "story_reac_laughter", math.random( 100,300 )
        )
      end
      self.npc[ npc_id ].new = false
    end
  elseif sound == "reac_story" then
    sound = ""
    if self.npc[ npc_id ].new == true then
      local dep
      if self.story_last then
        dep = sound_theme.theme[ self.selected_story ].depence[ self.story_last + 1 ]
      end
      if dep then
        if dep.type == "all" then
          xr_sound.set_sound_play( npc, dep.theme, math.random( 100,300 ) )
        else
          sound = dep.theme
        end
      end
    end
  elseif sound == "reac_story" then
    sound = ""
  else
    sound = ""
  end

  return state, sound, substate
end


function CKampManager:checkNpcAbility( npc )
  local npc_id = npc:id()
  if not self.npc[ npc_id ] then return end
  if
    self.npc[ npc_id ].begin
    and time_global() - self.npc[ npc_id ].begin < self.npc[ npc_id ].state_idle
  then
    return
  end
  if
    npc:character_community() ~= "monolith"
    and npc:character_community() ~= "zombied"
  then
    local inv = {}
    npc:iterate_inventory(
      function( npc, item )
        inv[ item:section() ] = true
      end,
      npc
    )
    local states = self.npc[ npc_id ].states
    states[ "trans" ] = false
    if self.npc[ npc_id ].can_eat then
      -- есть колбасу
      if inv[ "kolbasa" ] and math.random( 99 ) > 20 then
        -- вероятность 80%
        states[ "eat_kolbasa" ] = true
      else
        states[ "eat_kolbasa" ] = false
      end
      -- пить водку
      if inv[ "vodka" ] and math.random( 99 ) > 60 then
        -- вероятность 40%
        states[ "eat_vodka" ] = true
      else
        states[ "eat_vodka" ] = false
      end
      -- пить енергитический напиток
      if inv[ "energy_drink" ] and math.random( 99 ) > 40 then
        -- вероятность 60%
        states[ "eat_energy" ] = true
      else
        states[ "eat_energy" ] = false
      end
      -- есть хлеб
      if inv[ "bread" ] and math.random( 99 ) > 20 then
        -- вероятность 80%
        states[ "eat_bread" ] = true
      else
        states[ "eat_bread" ] = false
      end
      -- курит
      if inv[ "sigaret" ] and math.random( 99 ) > 20 then
        -- вероятность 80%
        states[ "kurit" ] = true
      else
        states[ "kurit" ] = false
      end
      -- пить из фляжки
      if inv[ "flaska" ] and math.random( 99 ) > 20 then
        -- вероятность 80%
        states[ "flaska" ] = true
      else
        states[ "flaska" ] = false
      end
      -- пить пиво
      if inv[ "beer_a" ] and math.random( 99 ) > 20 then
        -- вероятность 80%
        states[ "beer_a" ] = true
      else
        states[ "beer_a" ] = false
      end
      -- курит сигару
      if inv[ "cigara" ] and math.random( 99 ) > 20 then
        -- вероятность 80%
        states[ "kurit_cigara" ] = true
      else
        states[ "kurit_cigara" ] = false
      end
      -- есть бутерброд
      if inv[ "sandwich" ] and math.random( 99 ) > 20 then
        -- вероятность 80%
        states[ "eat_sandwich" ] = true
      else
        states[ "eat_sandwich" ] = false
      end
      -- играть на гармошке
      if inv[ "harmonica_a" ] then
        states[ "play_harmonica" ] = true
        states[ "wait_harmonica" ] = true
        self.kamp_states[ "pre_harmonica"  ] = true
        self.kamp_states[ "harmonica"      ] = true
        self.kamp_states[ "post_harmonica" ] = true
      else
        states[ "play_harmonica" ] = false
        states[ "wait_harmonica" ] = false
        self.kamp_states[ "pre_harmonica"  ] = false
        self.kamp_states[ "harmonica"      ] = false
        self.kamp_states[ "post_harmonica" ] = false
      end
    else
        states[ "eat_kolbasa"    ] = false
        states[ "eat_vodka"      ] = false
        states[ "eat_energy"     ] = false
        states[ "eat_bread"      ] = false
        states[ "kurit"          ] = false
        states[ "flaska"         ] = false
        states[ "beer_a"         ] = false
        states[ "kurit_cigara"   ] = false
        states[ "eat_sandwich"   ] = false
        states[ "play_harmonica" ] = false
        states[ "wait_harmonica" ] = false
        self.kamp_states[ "pre_harmonica"  ] = false
        self.kamp_states[ "harmonica"      ] = false
        self.kamp_states[ "post_harmonica" ] = false
    end

    -- втыкать в интернеты
    if inv[ "device_pda" ] and math.random( 99 ) > 50 then
      -- вероятность 50%
      states[ "use_pda" ] = true
    else
      states[ "use_pda" ] = false
    end
    -- играть на гитаре
    if inv[ "guitar_a" ] then
      states[ "play_guitar" ] = true
      states[ "wait_guitar" ] = true
      self.kamp_states[ "pre_guitar"  ] = true
      self.kamp_states[ "guitar"      ] = true
      self.kamp_states[ "post_guitar" ] = true
    else
      states[ "play_guitar" ] = false
      states[ "wait_guitar" ] = false
      self.kamp_states[ "pre_guitar"  ] = false
      self.kamp_states[ "guitar"      ] = false
      self.kamp_states[ "post_guitar" ] = false
    end
    -- играть на балалайке
    if inv[ "balalaika_a" ] then
      states[ "play_balalaika" ] = true
      states[ "wait_balalaika" ] = true
      self.kamp_states[ "pre_balalaika"  ] = true
      self.kamp_states[ "balalaika"      ] = true
      self.kamp_states[ "post_balalaika" ] = true
    else
      states[ "play_balalaika" ] = false
      states[ "wait_balalaika" ] = false
      self.kamp_states[ "pre_balalaika"  ] = false
      self.kamp_states[ "balalaika"      ] = false
      self.kamp_states[ "post_balalaika" ] = false
    end
    -- анекдоты
    if self.population > 1 then
      self.kamp_states[ "pre_joke"  ] = true
      self.kamp_states[ "joke"      ] = true
      self.kamp_states[ "post_joke" ] = true
    else
      self.kamp_states[ "pre_joke"  ] = false
      self.kamp_states[ "joke"      ] = false
      self.kamp_states[ "post_joke" ] = false
    end
  end

  -- Если чувак знает истории, надо добавить их к лагерю
  if self.population > 1 and db.story_by_id[ npc:id() ] ~= nil then
    self.kamp_states[ "story"      ] = true
    self.kamp_states[ "post_story" ] = true
  else
    self.kamp_states[ "story"      ] = false
    self.kamp_states[ "post_story" ] = false
  end
end


function CKampManager:addNpc( npc, bind )
  if self.npc[ npc:id() ] ~= nil then return end
  if
    npc:character_community() == "monolith"
    or npc:character_community() == "zombied"
  then
    self.npc[ npc:id() ] = {
      name     = npc:name(),
      can_eat  = ogse_kamp_eating.can_eat( npc ),
      position = nil,
      current  = nil,
      speak    = 0,
      states   = {
        beer_a         = false,
        declarate      = true,
        eat_bread      = false,
        eat_energy     = false,
        eat_kolbasa    = false,
        eat_sandwich   = false,
        eat_vodka      = false,
        flaska         = false,
        kurit          = false,
        kurit_cigara   = false,
        play_balalaika = false,
        play_guitar    = false,
        play_harmonica = false,
        play_joke      = false,
        play_story     = false,
        sit            = false,
        sit_ass        = false,
        sit_knee       = false,
        sweetness      = false,
        trans          = true,
        use_pda        = false,
      },
    }
  else
    self.npc[ npc:id() ] = {
      name     = npc:name(),
      can_eat  = ogse_kamp_eating.can_eat( npc ),
      position = nil,
      current  = nil,
      speak    = 0,
      states   = {
        beer_a         = false,
        declarate      = true,
        eat_bread      = false,
        eat_energy     = false,
        eat_kolbasa    = false,
        eat_sandwich   = false,
        eat_vodka      = false,
        flaska         = false,
        kurit          = false,
        kurit_cigara   = false,
        play_balalaika = false,
        play_guitar    = false,
        play_harmonica = false,
        play_joke      = false,
        play_story     = false,
        sit            = true,
        sit_ass        = true,
        sit_knee       = true,
        sweetness      = false,
        trans          = false,
        use_pda        = false,
      },
    }
  end
  self:selectPosition( npc:id(), bind )
  if db.story_by_id[ npc:id() ] == nil then
    local char_ini1 = ini_file( "scripts\\stories.ltx" )
    xr_info.loadInfo( npc, char_ini1 )
  end
end


function CKampManager:removeNpc( npc )
  local npc_id = npc:id()
  if self.npc[ npc_id ] == nil then return end
  -- Если удаляем режиссера - необходимо форсированно перевести лагерь
  -- в идловое состояние.
  if self.director == npc_id then
    self.npc[ npc_id ].begin = nil
    self.director   = nil
    self.censor     = nil
    self.kamp_state = "idle"
    self.begin      = time_global()
    for kk, vv in pairs( self.npc ) do
      vv.new = true
    end
    xr_sound.set_sound( npc, nil )
    stop_play_sound( npc )
  end
  if self.npc[ npc_id ].position ~= nil then
    self.position[ self.npc[ npc_id ].position ].used = nil
  end
  self.npc[ npc_id ] = nil
end


function CKampManager:increasePops( npc )
  self.population = self.population + 1
end


function CKampManager:decreasePops( npc )
  self.population = self.population - 1
end


-- Evaluators
-- Условие завершения скрипта
class "evaluator_kamp_end" ( property_evaluator )
function evaluator_kamp_end:__init( name, storage ) super( nil, name )
  self.a = storage
end

function evaluator_kamp_end:evaluate()
  return not xr_logic.is_active( self.object, self.a )
end


-- Находимся ли мы на заданной позиции
class "evaluator_on_position" ( property_evaluator )
function evaluator_on_position:__init( name, storage ) super( nil, name )
  self.a = storage
end

function evaluator_on_position:evaluate()
  if not self.a.updates_passed then
    self.a.updates_passed = 0
  elseif self.a.updates_passed < 20 then
    self.a.updates_passed = self.a.updates_passed + 1
  end
  if self.object:level_vertex_id() == self.a.pos_vertex then
    if self.a.updates_passed < 10 then
      return false
    end
    ogse_debug.add_active_eval( self.object, script_name(), "on_position" )
    return true
  end
  return false
end


--added by xStream--
-- Оп-па! Увидели труп поблизости от костра, непорядок...
class "evaluator_see_deadman" ( property_evaluator )
function evaluator_see_deadman:__init( name, storage ) super( nil, name )
  self.a = storage
end


function evaluator_see_deadman:evaluate()
  local npc = self.object
  -- Есть дела поважнее, чем трупы складировать...
  if not xr_logic.is_active( self.object, self.a ) then
    if self.a.choosed_deadman then
      deadmansids[ self.a.choosed_deadman ] = nil
      self.a.choosed_deadman = nil
      self.a.reached         = nil
    end
    return false
  end

  -- Труп себе уже выбрали, не спускаем с него глаз...
  if self.a.choosed_deadman then
    local obj = level.object_by_id( self.a.choosed_deadman )
    if
      obj
      and obj:position():distance_to(
        patrol( self.a.center_point ):point( 0 )
      ) < 20
    then
      ogse_debug.add_active_eval( self.object, script_name(), "see_deadman" )
      return true
    end
    -- если утащен далеко, то ну его нафиг...
    deadmansids[ self.a.choosed_deadman ] = nil
    self.a.choosed_deadman = nil
    self.a.reached         = nil
    return false
  end

  if
    not (
      self.a.see_deadman_t
      and (
        ( not last_death_t ) or self.a.see_deadman_t > last_death_t
      )
    )
  then
    for o in npc:memory_visible_objects() do
      if self:check_item( o:object() ) then return true end
    end
    -- for o in npc:memory_sound_objects() do
    --   self:check_item( o:object() )
    -- end
    -- for o in npc:not_yet_visible_objects() do
    --   self:check_item( o:object() )
    -- end
    self.a.see_deadman_t = time_global()
  end
  return false
end


function evaluator_see_deadman:check_item( obj )
  local npc = self.object
  -- если есть рядом с костром труп сталкера или монстра, его еще
  -- никто не прихватил себе и трупец нигде не застрял, то забираем
  -- его...
  if
    obj and obj.clsid and ( IsStalker( obj ) or IsMonster( obj ) )
    and ( not obj:alive() )
    and (
      ( not deadmansids[ obj:id() ] )
      or ( not level.object_by_id( deadmansids[ obj:id() ] ) )
      or ( not level.object_by_id( deadmansids[ obj:id() ] ):alive() )
    )
    and obj:position():distance_to(
      patrol( self.a.center_point ):point( 0 )
    ) < 10
  then
    if
      ( not deadmansidsuses[ obj:id() ] ) or deadmansidsuses[ obj:id() ] < 3
    then
      deadmansids[ obj:id() ]     = npc:id()
      self.a.choosed_deadman      = obj:id()
      deadmansidsuses[ obj:id() ] = ( deadmansidsuses[ obj:id() ] or 0 ) + 1
      -- ...заодно сразу прикидываем, куда бы его оттащить от костра,
      -- желательно под забор, стену дома и т.п., за неимением таковых
      -- - будем тащить куда попало, главное - подальше от костра
      self.a.drop_lvid = npc:level_vertex_id()
      local gi = level.object_by_id( self.a.choosed_deadman )
      if gi then
        local center     = gi:level_vertex_id()
        local center_pos = patrol( self.a.center_point ):point( 0 )
        local max_dist   = 0
        local tgt_vertex
        local base_dir   = gi:position():sub( center_pos )
        local base_point = npc:vertex_in_direction(
          center, gi:position():sub( center_pos ):mul( -1 ), 20
        )
        for ang = -90, 90, 20 do
          local cur_vert = npc:vertex_in_direction(
            base_point, vector_rotate_y( base_dir, ang ), 20
          )
          local dist = level.vertex_position( cur_vert )
            :distance_to( center_pos )
          if dist > 11 and dist < 17 then
            if dist > max_dist then
              max_dist   = dist
              tgt_vertex = cur_vert
            end
          end
        end
        if not tgt_vertex then
          tgt_vertex = npc:vertex_in_direction(
            base_point,
            vector_rotate_y( base_dir, math.random() * 180 - 90 ),
            20
          )
        end
        self.a.drop_lvid = tgt_vertex
        self.a.ps        = gi:get_physics_shell()
      end
      ogse_debug.add_active_eval(
        self.object, script_name(), "see_deadman_2"
      )
      return true
    end
  end
  return false
end


-- Тащим труп
class "evaluator_can_move_deadman" ( property_evaluator )
function evaluator_can_move_deadman:__init( name, storage ) super( nil, name )
  self.a = storage
end

function evaluator_can_move_deadman:evaluate()
  local npc = self.object
  local obj = level.object_by_id( self.a.choosed_deadman )
  if not ( self.a.reached == 1 and obj ) then return false end
  -- если труп застрял (расстояние увеличилось), то возвращаемся к
  -- нему или если ГГ подошел, то уделяем ему чуточку внимания
  local pos = obj:bone_position( "bip01_spine1" )
  return pos:distance_to( npc:position() ) < 2
    and pos:distance_to( db.actor:position() ) > 3
end


-- Actions
-- ' Идет в заданную область
class "action_go_position" (action_base)
function action_go_position:__init (npc_name,action_name,storage) super (nil,action_name)
  self.a = storage
end
function action_go_position:initialize()
        action_base.initialize(self)
        self.object:set_desired_position()
        self.object:set_desired_direction()
        
        self.a.pos_vertex = nil
end

local already_catched = {}

function clear_catch(npc)
        for k, v in pairs(already_catched) do
                if v == npc:id() then
                        k = nil
                end
        end
end

function action_go_position:check_npc_block(object, dest_vtx)
        local blocked_vtx = {}
        for npc_id, is_npc in pairs(db.creature) do
                if is_npc then
                        local npc = level.object_by_id(npc_id)
                        if npc and object:id() ~= npc_id then
                                blocked_vtx[npc:level_vertex_id()] = npc_id
                        end
                end
        end
        for k, v in pairs(blocked_vtx) do
                if k == dest_vtx then
                        return true
                end
        end
        return false
end
function action_go_position:execute ()
        action_base.execute (self)

        if db.actor then
                if xr_logic.try_switch_to_another_section(self.object, self.a, db.actor) then
                        return
                end
        end     
        
        if not ( self.a.updates_passed and self.a.updates_passed >= 10 ) then
          return
        end
        
        
        local tmp_pos_vertex = self.a.kamp:getDestVertex(self.object:id(), self.a.radius)
        
        
        if self.a.pos_vertex ~= tmp_pos_vertex then
                self.a.pos_vertex = tmp_pos_vertex
                
                if self.object:position():distance_to(level.vertex_position(self.a.pp)) < 1.5 or not self.a.pos_vertex then
                        -- вообще никуда идти не надо
                        self.a.pos_vertex = self.object:level_vertex_id()
                end
                
                if not already_catched[self.a.pos_vertex] then
                        already_catched[self.a.pos_vertex] = self.object:id()
                end
                
                if not self.object:accessible(self.a.pos_vertex) 
                or (already_catched[self.a.pos_vertex] and not already_catched[self.a.pos_vertex] == self.object:id()) 
                or self:check_npc_block(self.object, self.a.pos_vertex)
                then
                        --log3("!!ACTION action_go_position [%s] KAMP NODE NOT ACCESSIBLE. Get accessible nearest", self.object:name())
                        local ttp = vector():set(math.random(-1,1),0,math.random(-1,1))
                        self.a.pos_vertex = self.object:accessible_nearest(level.vertex_position(self.a.pos_vertex), ttp)
                end
                
                
                self.a.pp = patrol(self.a.center_point):level_vertex_id(0)
                self.a.pp = level.vertex_in_direction(self.a.pp, vector():set(math.random(-1,1), 0, math.random(-1,1)), math.random(0,0.5))
                self.object:set_dest_level_vertex_id(self.a.pos_vertex)
                self.object:set_desired_direction(vector():sub(level.vertex_position(self.a.pp),level.vertex_position(self.a.pos_vertex)))
                self.object:set_detail_path_type ( move.curve )
                self.object:set_path_type(game_object.level_path)
                state_mgr.set_state(self.object, self.a.def_state_moving)
                
        end
end
function action_go_position:finalize ()
        action_base.finalize (self)
end

--' Просто сидит и втыкает
class "action_wait" (action_base)
function action_wait:__init (npc_name,action_name,storage) super (nil,action_name)
        self.a = storage
end
function action_wait:initialize()
        action_base.initialize(self)
        self.object:set_desired_position()
        self.object:set_desired_direction()
        
        self.a.kamp:increasePops( self.object )
end
function action_wait:activate_scheme()
end
function action_wait:execute()
        action_base.execute (self)
        if db.actor then
                if xr_logic.try_switch_to_another_section(self.object, self.a, db.actor) then
                        return
                end
        end
        local state, sound, substate = self.a.kamp:updateNpc( self.object )
        
        if state == nil then
                state = "wait"
                --log1("!!XR_CAMP WARNING - CAMP UPDATE CANNOT RETRIEVE STATE")
        end
        
        --' повернуть его лицом к центру        
        state_mgr.set_state(self.object, state, nil, nil, {look_position = level.vertex_position(self.a.pp)}, nil, nil, {subanim = substate})
        xr_sound.set_sound(self.object, sound)
end
function action_wait:finalize()
        clear_catch(self.object)
        self.a.kamp:decreasePops( self.object )
        action_base.finalize (self)
end
function action_wait:deactivate(npc)
        clear_catch(self.object)
        self.a.kamp:removeNpc( npc )
end
function action_wait:death_callback(npc)
        clear_catch(self.object)
        self.a.kamp:removeNpc( npc )
end
function action_wait:net_destroy(npc)
        clear_catch(self.object)
        self.a.kamp:decreasePops( self.object )
        self.a.kamp:removeNpc( npc )
end
--added by xStream--
--Идет к бездыханному товарищу
class "action_go_to_deadman" (action_base)
function action_go_to_deadman:__init (npc_name,action_name,storage) super (nil,action_name)
        self.a = storage
end
function action_go_to_deadman:initialize()
        action_base.initialize(self)
        local npc=self.object
        local gi=level.object_by_id(self.a.choosed_deadman)
        if gi then 
                --попремся в сторону головы - за шкирятник тащить бум
                self.a.dest_lvid=gi:level_vertex_id()
                local diff=gi:bone_position("bip01_spine"):sub(gi:position())
                local len=diff:magnitude()*2.5
                self.a.dest_lvid=npc:vertex_in_direction(self.a.dest_lvid,diff,len)
                        if not npc:accessible(self.a.dest_lvid) then
                                self.a.dest_lvid = npc:accessible_nearest(level.vertex_position(self.a.dest_lvid), vector():set(0,0,0))
                        end
        else
                self.a.dest_lvid=npc:level_vertex_id()
        end
        self.a.reached=0
        self.a.cur_dead_lvid=gi:level_vertex_id()
        --пойдем не спеша...
        state_mgr.set_state(self.object, self.a.def_state_moving)
        --на все гулянки в сторону трупа дается 30 секунд, если не успел, то да ну нафиг заморачиваться :)
        self.a.go_time_end=time_global()+30000
        self.a.captures = (self.a.captures or 0) + 1
        xr_sound.set_sound(npc, nil)
        stop_play_sound(npc)
end

function action_go_to_deadman:execute ()
        action_base.execute (self)
        local npc=self.object
  local gi=level.object_by_id(self.a.choosed_deadman)
        -- если уже задолбало дергать труп, а он застрял (дергаем 3 раза), то нафиг его
        -- так же если какой то мимопроходящий товарищ труп с места сдвинул - то туда ему и дорога (трупу), а нам он больше не интересен
  if self.a.captures==4 or self.a.go_time_end<time_global() or gi==nil or gi:level_vertex_id()~=self.a.cur_dead_lvid then
        if self.a.choosed_deadman then
                deadmansids[self.a.choosed_deadman]=nil
                self.a.choosed_deadman=nil
                self.a.reached=nil              
        end
                self.a.captures=nil
  else
                npc:set_dest_level_vertex_id(self.a.dest_lvid)
                -- долгое путешествие до трупа успешно завершилось, ура, товарищи
    if self.a.dest_lvid and self.a.dest_lvid==npc:level_vertex_id() then
      self.a.reached=1
    end
  end
end

function action_go_to_deadman:finalize ()
        action_base.finalize (self)
end

--Тащит трупец
class "action_moving_deadman" (action_base)
function action_moving_deadman:__init (npc_name,action_name,storage) super (nil,action_name)
        self.a = storage
end
function action_moving_deadman:initialize()
        action_base.initialize(self)
  local npc=self.object
  --если пушка в руках - прячем, а то тащить неудобно
  if npc:weapon_unstrapped() then
    npc:set_item(object.idle,nil)
  end
        --потащим медленно, осторожно и на карачках
        npc:set_movement_type(move.walk)
        npc:set_mental_state(anim.danger)
        npc:set_body_state(move.crouch)
        npc:movement_enabled(true)

        --на таскание трупа в грязи даем 40 секунд
  self.a.time_end=time_global()+40000
  self.force=vector():set(0,0,0)
        --на приседание рядом с трупом и разворот лицом дадим секунду
  self.time_drag=time_global()+1000
end

function action_moving_deadman:execute ()
        action_base.execute (self)
  local npc=self.object
  local gi=level.object_by_id(self.a.choosed_deadman)
  
        --хватит таскать труп - время истекло, пусть другие этим занимаются
  if self.a.time_end<time_global() then
        if self.a.choosed_deadman then
                deadmansids[self.a.choosed_deadman]=nil
                self.a.choosed_deadman=nil
                self.a.reached=nil              
        end
    return 
  end
        
        -- смотри мне в глаза!
        local dir=gi:position():sub(npc:position())
        dir.y=0
        npc:set_movement_type(move.walk)
        npc:set_mental_state(anim.danger)
        npc:set_body_state(move.crouch)
        npc:movement_enabled(true)
        npc:set_sight(look.direction,dir,true)

  if self.a.ps and self.time_drag<time_global() then
    npc:set_dest_level_vertex_id(self.a.drop_lvid)
        -- непись сильный - тащит левой рукой за туловище трупа
        local bone="bip01_spine1"
    local dir=npc:bone_position("bip01_l_hand"):sub(gi:bone_position(bone))
    dir:mul(25000)
        dir.y=9000
    self.force:mul(0.5)
    dir:mul(0.5)
    self.force:add(dir)
    if self.a.ps:get_element_by_bone_name(bone) then
                self.a.ps:get_element_by_bone_name(bone):apply_force(self.force.x,self.force.y,self.force.z)
    else
    end
  end
  
        -- уф! дотащили... всем спасибо, все свободны...
  if self.a.drop_lvid and self.a.drop_lvid==npc:level_vertex_id() then
        if self.a.choosed_deadman then
                deadmansids[self.a.choosed_deadman]=nil
                self.a.choosed_deadman=nil
                self.a.reached=nil              
        end
  end
end

function action_moving_deadman:finalize ()
        action_base.finalize (self)
        state_mgr.set_state(self.object, self.a.def_state_moving)
end


-- Kamp binder
function add_to_binder( object, ini, scheme, section, storage )
  local properties = {
    [ "kamp_end"         ] = xr_evaluators_id.stohe_kamp_base + 1,
    [ "on_position"      ] = xr_evaluators_id.stohe_kamp_base + 2,
    [ "see_deadman"      ] = xr_evaluators_id.stohe_kamp_base + 3,
    [ "can_move_deadman" ] = xr_evaluators_id.stohe_kamp_base + 5,
    [ "contact"          ] = xr_evaluators_id.stohe_meet_base + 1,
    [ "state_mgr_off"    ] = xr_evaluators_id.state_mgr + 3,
  }

  local operators  = {
    [ "go_position"   ] = xr_actions_id.stohe_kamp_base + 1,
    [ "wait"          ] = xr_actions_id.stohe_kamp_base + 3,
    [ "go_to_deadman" ] = xr_actions_id.stohe_kamp_base + 4,
    [ "move_deadman"  ] = xr_actions_id.stohe_kamp_base + 5,
  }

  -- Evaluators
  local manager = object:motivation_action_manager()
  manager:add_evaluator(
    properties.kamp_end,
    this.evaluator_kamp_end( "kamp_end", storage, "kamp_end" )
  )
  manager:add_evaluator(
    properties.on_position,
    this.evaluator_on_position(
      "kamp_on_position", storage, "kamp_on_position"
    )
  )

  local zombi = object:character_community() == "zombied"
    or object:character_community() == "trader"
    or object:character_community() == "arena_enemy"
    or object:name() == "mil_stalker0012"
    or object:name() == "yantar_ecolog_general"
  if zombi then
    manager:add_evaluator(
      properties.see_deadman, property_evaluator_const( false )
    )
    manager:add_evaluator(
      properties.can_move_deadman, property_evaluator_const( false )
    )
  else
    manager:add_evaluator(
      properties.see_deadman,
      this.evaluator_see_deadman( "see_deadman", storage, "see_deadman" )
    )
    manager:add_evaluator(
      properties.can_move_deadman,
      this.evaluator_can_move_deadman(
        "can_move_deadman", storage, "can_move_deadman"
      )
    )
  end

  -- Actions
  local action = this.action_wait( object:name(), "action_kamp_wait", storage )
  action:add_precondition(
    world_property( stalker_ids.property_alive,   true  )
  )
  action:add_precondition(
    world_property( stalker_ids.property_danger,  false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_enemy,   false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_anomaly, false )
  )
  action:add_precondition(
    world_property( properties.see_deadman,       false )
  )
  xr_motivator.addCommonPrecondition( action )
  action:add_precondition(
    world_property( properties.on_position,       true  )
  )
  action:add_effect( world_property( properties.kamp_end, true ) )
  manager:add_action( operators.wait, action )
  xr_logic.subscribe_action_for_events( object, storage, action )

  action = this.action_go_position( object:name(), "action_go_kamp", storage )
  action:add_precondition(
    world_property( stalker_ids.property_alive,   true  )
  )
  action:add_precondition(
    world_property( stalker_ids.property_danger,  false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_enemy,   false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_anomaly, false )
  )
  action:add_precondition(
    world_property( properties.see_deadman,       false )
  )
  xr_motivator.addCommonPrecondition( action )
  action:add_precondition(
    world_property( properties.on_position,       false )
  )
  action:add_effect( world_property( properties.on_position, true ) )
  manager:add_action( operators.go_position, action )

  -- видим труп - идем разбираться...
  action = this.action_go_to_deadman(
    object:name(), "action_go_to_deadman", storage
  )
  action:add_precondition(
    world_property( stalker_ids.property_alive,   true  )
  )
  action:add_precondition(
    world_property( stalker_ids.property_danger,  false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_enemy,   false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_anomaly, false )
  )
  xr_motivator.addCommonPrecondition( action )
  action:add_precondition(
    world_property( properties.see_deadman,       true  )
  )
  action:add_precondition(
    world_property( properties.can_move_deadman,  false )
  )
  action:add_precondition(
    world_property( properties.kamp_end,          false )
  )
  action:add_effect( world_property( properties.can_move_deadman, true ) )
  manager:add_action( operators.go_to_deadman, action )

  -- тащим труп подальше от тусовки
  action = this.action_moving_deadman(
    object:name(), "action_moving_deadman", storage
  )
  action:add_precondition(
    world_property( stalker_ids.property_alive,   true  )
  )
  action:add_precondition(
    world_property( stalker_ids.property_danger,  false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_enemy,   false )
  )
  action:add_precondition(
    world_property( stalker_ids.property_anomaly, false )
  )
  xr_motivator.addCommonPrecondition( action )
  action:add_precondition(
    world_property( properties.see_deadman,       true  )
  )
  action:add_precondition(
    world_property( properties.can_move_deadman,  true  )
  )
  action:add_precondition(
    world_property( properties.kamp_end,          false )
  )
  action:add_effect( world_property( properties.see_deadman,      false ) )
  action:add_effect( world_property( properties.can_move_deadman, false ) )
  manager:add_action( operators.move_deadman, action )

  action = manager:action(xr_actions_id.alife )
  action:add_precondition(
    world_property( properties.kamp_end, true )
  )
end


-- включение лагеря
function set_scheme( npc, ini, scheme, section, gulag_name )
  local st = xr_logic.assign_storage_and_bind( npc, ini, scheme, section )
  st.logic        = xr_logic.cfg_get_switch_conditions( ini, section, npc )
  st.center_point = utils.cfg_get_string(
    ini, section, "center_point", npc, true, gulag_name
  )
  st.radius       = utils.cfg_get_number(
    ini, section, "radius", npc, false, 2
  )
  local bind      = utils.cfg_get_number( ini, section, "bind", npc, false )
  st.kamp         = get_my_kamp( npc, st.center_point )
  st.kamp:addNpc( npc, bind )
  st.pos_vertex   = nil

  st.def_state_moving = utils.cfg_get_string(
    ini, section, "def_state_moving", npc, false, "", "walk"
  )
  if st.def_state_moving == nil or st.def_state_moving == "nil" then
    st.def_state_moving = "walk"
  end
end
