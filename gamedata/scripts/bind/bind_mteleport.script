-- -*- mode: lua; coding: windows-1251-dos -*-
-- ************************************************
-- **                    Imp                     **
-- **       Биндер самодельных телепортов        **
-- ** Поддерживает работу самопальных телепортов **
-- **    Proper70 доработано для поддержания     **
-- **    функций рестриктора и выдачи поршней,   **
-- **    а также поддержки формы телепорта box   **
-- ************************************************

-- Proper70 в конфиг добавлены параметры для поддержания функций
-- рестриктора и выдачи поршней:
--
-- info = vzn_temp1 -- есди задано - выдается этот поршень
--
-- func = kostya_dialog.give_ammo(1)-- если задано - вызывается эта
-- функция с указанными параметрами, все писать без пробелов.
--
-- для создания телепорта в форме box в конфиге можно задавать 3 параметра:
-- x_radius, y_radius, z_radius. z_radius = высота.


function abs_comp( a, b )
  -- Служебная функция вычисления разности
  if a < b then
    return b - a
  else
    return a - b
  end
end


function bind( obj )
  obj:bind_object( restrictor_teleport( obj ) )
end


class "restrictor_teleport" ( object_binder )
function restrictor_teleport:__init( obj ) super( obj )
  self.sm = ogse_signals.get_mgr()
end


function restrictor_teleport:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then
    return false
  end
  local sect = self.object:section()
  if not get_bool( sect, "teleport" ) then return true end
  -- Заполним таблицу параметров
  self.parametrs = {}
  local t = self.parametrs
  if sys_ini:line_exist( sect, "radius" ) then
    t.x_radius = get_float( sect, "radius" )
    t.y_radius = get_float( sect, "radius" )
  else
    t.x_radius = 2 -- Дефолтный радиус по xy
    t.y_radius = 2 -- Дефолтный радиус по xy
  end
  if sys_ini:line_exist( sect, "z_radius" ) then
    t.z_radius = get_float( sect, "z_radius" )
  else
    -- если радиус высоты не задан то задаем равным радиусу xy
    t.z_radius = t.x_radius
  end
  --  параметры box
  if sys_ini:line_exist( sect, "x_radius" ) then
    t.x_radius = get_float( sect, "x_radius" )
  end
  if sys_ini:line_exist( sect, "y_radius" ) then
    t.y_radius = get_float( sect, "y_radius" )
  end
  -- Запомним позицию что-бы каждый раз не считать
  local pos = self.object:position()
  t.x = pos.x
  t.y = pos.y
  t.z = pos.z
  -- Запомним координаты куда телепортимся
  t.pos_rnd_radius = get_float( sect, "pos_rnd_radius" )
  t.poz_rnd = get_u32( sect, "poz_rnd" )
  local s   = t.poz_rnd and math.random( t.poz_rnd ) or ""
  t.poz_x   = get_float( sect, "poz_x" .. s )
  t.poz_y   = get_float( sect, "poz_y" .. s )
  t.poz_z   = get_float( sect, "poz_z" .. s )
  t.rotate  = get_float( sect, "rotate" )
  -- Функции рестриктора
  -- выдать поршень
  t.info = get_string( sect, "info" )
  -- выполнить функцию
  t.func = get_string( sect, "func" )
  local cond = get_string( sect, "cond" )
  if cond then
    t.cond = xr_logic.parse_condlist( self.object, sect, "cond", cond )
  end
  self.subscribed = {
    [ "signal" ] = "on_update",
    [ "fun"    ] = self.actor_update,
    [ "self"   ] = self,
    [ "script_name" ] = "bind_mteleport.actor_update",
  }
  self.sm:subscribe( self.subscribed )
  return true
end


function restrictor_teleport:net_destroy()
  -- Удаляем наш телепорт
  if self.subscribed then
    self.sm:unsubscribe( self.subscribed )
    self.subscribed = nil
  end
  self.parametrs = nil
  object_binder.net_destroy( self )
end


function restrictor_teleport:actor_update()
  local s = self.parametrs
  if s.teleporte then
    -- Телепорт запущен
    local pos = db.actor:position()
    ogse.save_var(
      "bind_mteleport.orig_pos", { pos.x, pos.y, pos.z }, "vector"
    )
    db.actor:set_actor_position( vector():set( s.poz_x, s.poz_y, s.poz_z ) )
    if s.rotate then
      db.actor:set_actor_direction( s.rotate )
    end
    -- выполняем функции рестриктора
    if s.info then
      -- выдаем поршень
      db.actor:give_info_portion( s.info )
    end
    if s.func then
      -- выполняем функцию
      local f, err = loadstring( s.func )
      ASSERT( f, err )
      f()
    end
    s.teleporte = false
    db.actor:give_info_portion( "teleport_finished" )
    -- Звуковое сопровождение
    local snd_obj = xr_sound.get_safe_sound_object(
      "anomaly\\teleport_work_1"
    )
    snd_obj:play_no_feedback( db.actor, sound_object.s2d, 0, vector():set( 0, 0, 0 ), 1.0 )
  else
    -- Проверим не забрел ли актор в наш телепорт
    local acter_poz = db.actor:position()
    if
      abs_comp( s.x, acter_poz.x ) < s.x_radius
      and abs_comp( s.z, acter_poz.z ) < s.y_radius
      and abs_comp( s.y, acter_poz.y ) < s.z_radius
      and (
        ( not s.cond )
        or xr_logic.pick_section_from_condlist(
          db.actor, self.object, s.cond
        ) ~= nil
      )
    then
      local can_teleport = true
      if s.pos_rnd_radius then
        local pos = dsh.get_random_pos_in_radius( s.pos_rnd_radius, 25 )
        if pos then
          s.poz_x, s.poz_y, s.poz_z = pos.x, pos.y, pos.z
        else
          can_teleport = false
        end
      end
      if can_teleport then
        -- Актер в зоне действия телепорта, запустим телепорт
        db.actor:give_info_portion( "teleport_started" )
        s.teleporte = true
        self.sm:reschedule( 1000 )
        -- Запускаем спецэфекты телепортации
        level.add_pp_effector( "teleport.ppe", 2006, false )
        return
      end
    end
  end
  local dist = self.object:position():distance_to( db.actor:position() )
  self.sm:reschedule(
    ( dist < 25 and 200 ) or ( dist < 100 and 1000 )
    or math.random( 5000, 6000 )
  )
end
