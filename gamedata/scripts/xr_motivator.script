--/amk_rel_1/
--[[------------------------------------------------------------------------------------------------------------------
автор: Диденко Руслан (Stohe)

порядок вызова методов биндера:
reload
reinit
load
net_spawn
--------------------------------------------------------------------------------------------------------------------]]
local table_remove = table.remove
memtsg = {} --' временная таблица
lasthealth = 0
lastime = nil

local warn_check_timer = {}
local snd_check_timer = {}

local particles={}

----------------------------------------------------------------------------------------------------------------------
function look_to_shot(object, who)
	if object and who then
		if IsStalker(object) and 
		(object:alive() and who:alive()) and
		not xr_wounded.is_wounded(object) and
		((IsStalker(who) and object:relation(who) ~= game_object.friend) or IsMonster(who)) then
			if object:best_enemy() then
				local be = object:best_enemy()
				local enemy_dist = object:position():distance_to_sqr(be:position())
				local who_dist = object:position():distance_to_sqr(who:position())
				if who_dist < enemy_dist then
					object:set_sight(look.danger,who:bone_position("bip01_head"))
				end		
			else	
				object:set_sight(look.danger,who:bone_position("bip01_head"))
			end
		end
	end
end

function recognize_sound(sound_type)
	-- Выясняем тип звука
	local sn_t = "NIL"
	
	if bit_and(sound_type, snd_type.weapon) == snd_type.weapon then
		sn_t = "WPN"
		if bit_and(sound_type, snd_type.weapon_shoot) == snd_type.weapon_shoot then
			sn_t = "WPN_shoot"
		elseif bit_and(sound_type, snd_type.weapon_empty) == snd_type.weapon_empty then
			sn_t = "WPN_empty"
		elseif bit_and(sound_type, snd_type.weapon_bullet_hit) == snd_type.weapon_bullet_hit then
			sn_t = "WPN_hit"
		elseif bit_and(sound_type, snd_type.weapon_reload) == snd_type.weapon_reload then
			sn_t = "WPN_reload"
		end
	elseif bit_and(sound_type, snd_type.item) == snd_type.item then
		sn_t = "ITM"
		if bit_and(sound_type, snd_type.item_pick_up) == snd_type.item_pick_up then
			sn_t = "ITM_pckup"
		elseif bit_and(sound_type, snd_type.item_drop) == snd_type.item_drop then
			sn_t = "ITM_drop"
		elseif bit_and(sound_type, snd_type.item_hide) == snd_type.item_hide then
			sn_t = "ITM_hide"
		elseif bit_and(sound_type, snd_type.item_take) == snd_type.item_take then
			sn_t = "ITM_take"
		elseif bit_and(sound_type, snd_type.item_use) == snd_type.item_use then
			sn_t = "ITM_use"
		end
	elseif bit_and(sound_type, snd_type.monster) == snd_type.monster then
		sn_t = "MST"
		if bit_and(sound_type, snd_type.monster_die) == snd_type.monster_die then
			sn_t = "MST_die"
		elseif bit_and(sound_type, snd_type.monster_injure) == snd_type.monster_injure then
			sn_t = "MST_damage"
		elseif bit_and(sound_type, snd_type.monster_step) == snd_type.monster_step then
			sn_t = "MST_step"
		elseif bit_and(sound_type, snd_type.monster_talk) == snd_type.monster_talk then
			sn_t = "MST_talk"
		elseif bit_and(sound_type, snd_type.monster_attack) == snd_type.monster_attack then
			sn_t = "MST_attack"
		elseif bit_and(sound_type, snd_type.monster_eat) == snd_type.monster_eat then
			sn_t = "MST_eat"
		end
	elseif sound_type == snd_type.attack then
		sn_t = "ATTCK"
	elseif sound_type == snd_type.bullet_hit then
		sn_t = "BULLET"
	elseif sound_type == snd_type.die then
		sn_t = "DIE"
	elseif sound_type == snd_type.injure then
		sn_t = "INJURE"
	end
	
	return sn_t
end

local hear_something = {

[1] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_1]],
[2] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_2]],
[3] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_3]],
[4] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_4]],
[5] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_5]],
[6] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_6]],
[7] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_7]],
[8] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_8]],
[9] = [[characters_voice\human_01\dolg\reactions\hear_something\hear_9]]

}

local nothing_there = {

[1] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_1]],
[2] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_2]],
[3] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_3]],
[4] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_4]],
[5] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_5]],
[6] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_6]],
[7] = [[characters_voice\human_01\dolg\reactions\nothing\nothing_7]]

}


function silent_level()
	if 	level.name() == "l06_rostok" or
		level.name() == "l08u_brainlab" or
		level.name() == "l10u_bunker" or
		level.name() == "l12_stancia" or 
		level.name() == "l12u_sarcofag" or
		level.name() == "l12u_control_monolith" or
		level.name() == "l12_stancia_2" then
		return true 
	else 
		return false
	end
end

function check_sound(self, who, sound_type, sound_position, sound_power)
	-- secure and optimize
	
	if not self or
		not who or
		not sound_type or
		not sound_position or
		not sound_power 
	then
		return 
	end
	
	local actsch = nil
	
	if db.storage[self:id()] and db.storage[self:id()].active_scheme then
		actsch = db.storage[self:id()].active_scheme
	end
	
	if actsch and (actsch == "remark" or actsch == "wounded" or actsch == "actor_dialogs")
	then 
		return 
	end

	-- Реакция на звуки --
	-- Расстояния проверки
	local who_dist = 1000
	local check_dist = 25*sound_power
	local who_dist = self:position():distance_to(who:position())
	
	if who_dist > 100 then
		return
	end
	
	-- Отсеиваем свои звуки и звуки друзей
	if (who:is_monster() or who:is_stalker() or who:id() == db.actor:id()) 
	and (who:alive() and self:alive()) then
		if who:id() == self:id() 
		or (who:is_car() and self:relation(db.actor) ~= game_object.enemy)
		or xr_wounded.is_wounded(self) then
			return
		end
	else	
		return
	end
	
	local snd_t = recognize_sound(sound_type)
	
	local blow = hit()
	blow.power = 0.001
	blow.impulse = 1
	blow.draftsman = who
	blow.type = hit.wound
	blow.direction = utils.vector_copy_by_val(self:position()):sub(who:position())
	
	-- Если тип задан проверим реакцию на него
	if snd_t and snd_t ~= "NIL" and not self:best_enemy() then
		if IsStalker(who) and (self:relation(who) == game_object.enemy) then
			if snd_t == "WPN_empty" or
			snd_t == "WPN_reload" or 
			snd_t == "ITM_drop" or
			snd_t == "ITM_use" then		
				check_dist = 8*sound_power
				who_dist = self:position():distance_to(who:position())
				if who_dist > check_dist then
					if not silent_level() then
						if not warn_check_timer[self:id()] or warn_check_timer[self:id()] < time_global() then
							local snd_name = nothing_there[math.random(1,7)]
							if snd_name and self:character_community() ~= "zombied" then
								local snd_obj = xr_sound.get_safe_sound_object(snd_name)
								if snd_obj and not snd_obj:playing() then
									self:set_sight(look.point,sound_position)
									snd_obj:play_no_feedback(self, sound_object.s3d, 0, self:position(), 1.0)
									warn_check_timer[self:id()] = time_global() + math.random(15000, 25000) 
								end
							end
						end
					end				
					return
				else
					if not silent_level() then
						if not warn_check_timer[self:id()] or warn_check_timer[self:id()] < time_global() then
							local snd_name = hear_something[math.random(1,9)]
							if snd_name and self:character_community() ~= "zombied" then
								local snd_obj = xr_sound.get_safe_sound_object(snd_name)
								if snd_obj and not snd_obj:playing() then
									self:set_sight(look.point,sound_position)
									snd_obj:play_no_feedback(self, sound_object.s3d, 0, self:position(), 1.0)
									warn_check_timer[self:id()] = time_global() + math.random(5000, 10000) 
								end
							end
						end
					end
					self:set_sight(look.point,sound_position)
					self:set_mental_state(anim.danger)
					self:make_object_visible_somewhen(who)
				end
			elseif snd_t == "WPN_shoot" then
				-- self:hit(blow) -- попробуем без хита прямого, поглядим что будет
				stop_play_sound(self)
				self:set_mental_state(anim.danger)
				self:set_sight(look.point,sound_position)
				self:make_object_visible_somewhen(who)	
--[[
				if xr_companion.is_companion(self:id()) then
					xr_combat_companion.process_enemy(self, who)				
				end			
]]
			end
		elseif IsStalker(who) and (self:relation(who) ~= game_object.enemy) then
			if snd_t == "ATTCK" or
			snd_t == "BULLET" or
			snd_t == "DIE" or
			snd_t == "INJURE" then
				self:set_sight(look.point,sound_position)
				self:set_mental_state(anim.danger)			
			end			
		elseif IsMonster(who) then
			if who_dist > check_dist then
				if not silent_level() then
					if not warn_check_timer[self:id()] or warn_check_timer[self:id()] < time_global() then
						local snd_name = nothing_there[math.random(1,7)]
						if snd_name and self:character_community() ~= "zombied" then
							local snd_obj = xr_sound.get_safe_sound_object(snd_name)
							if snd_obj and not snd_obj:playing() then
								self:set_sight(look.point,sound_position)
								snd_obj:play_no_feedback(self, sound_object.s3d, 0, self:position(), 1.0)
								warn_check_timer[self:id()] = time_global() + math.random(15000, 25000) 
							end
						end
					end
				end				
				return
			end		
			if snd_t == "MST_step" or snd_t == "MST_talk" then
				self:set_sight(look.point,sound_position)
				self:set_mental_state(anim.danger)
				self:make_object_visible_somewhen(who)
			elseif snd_t == "MST_attack" then
				self:hit(blow)
				stop_play_sound(self)
				self:set_sight(look.point,sound_position)
				self:set_mental_state(anim.danger)
				self:make_object_visible_somewhen(who)
			end
		end
	end
end

class "motivator_binder" (object_binder)

function motivator_binder:__init (obj) super(obj)
  self.loaded = false
  self.last_update = 0
        self.prev_ammo = -1
  ----memusage.collect_info(self.object, "__init")

    self.first_update = false
  self.treasure_processed = false
        self.particles = {}
  self.rot_time = 65535
	self.am = ogse_signals.get_mgr()
end

function motivator_binder:extrapolate_callback(cur_pt)
        if self.object == nil then return false end
  if self.st.active_section then
    xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "extrapolate_callback")
    self.st.move_mgr:extrapolate_callback(self.object)
  end

  if patrol(self.object:patrol()):flags(cur_pt):get() == 0 then
    return true
  end
  return false
end

function motivator_binder:reinit()
        if self.object == nil then return end
    object_binder.reinit(self)
    --memusage.collect_info(self.object, "reinit_start")
    --printf("motivator_binder:reinit(): self.object:name()='%s'", self.object:name())

    -- КОЛЛБЕКИ ЗДЕСЬ СТАВИТЬ НЕЛЬЗЯ! Здесь еще неизвестна активная схема.
    -- Ставьте коллбеки в методе update в отмеченном комментарием месте.

    local char_ini = self.object:spawn_ini() or ini_file("scripts\\dummy.ltx")

----------------------------------------------------------------------------------------------------------------------
-- Общие скрипты
----------------------------------------------------------------------------------------------------------------------
    db.storage[self.object:id()] = {  followers = {} }
    self.st = db.storage[self.object:id()]

    --' Создание менеджера контроля положений тела
    --memusage.collect_info(self.object, "before_statemgr")
  self.st.state_mgr = state_mgr.bind_manager(self.object)

  self.st.move_mgr = move_mgr.move_mgr(self.object)
  self.st.move_mgr:initialize()

  --memusage.collect_info(self.object, "after_statemgr")
  --memusage.collect_info(self.object, "reinit_end")
end
----------------------------------------------------------------------------------------------------------------------
function motivator_binder:net_spawn(sobject)
  printf("motivator_binder:net_spawn(): self.object:name()='%s'", self.object:name())
  --memusage.collect_info(self.object, "netspawn_start")
  if not object_binder.net_spawn(self, sobject) then
    return false
  end
  
  self.rot = self.rot_time <= amk.game_hours()
  
--[[
  local sim = alife()
  local npc=self.object
  local zomb=amk.load_table("zombies")
  for k,v in pairs(zomb) do
    if k==npc:id() then
      if sim:object(v.master) and sim:object(v.master).alive and (not sim:object(v.master):alive()) then
        if amk_mod.dezombify(k,v) then
          zomb[k]=nil
        end
      end
    end
  end
  amk.save_table("zombies",zomb)
]]

--  if self.object:spawn_ini():section_exist("dont_spawn_online") then
--    printf("!!!OFFLINE")
--    alife():object(self.object:id()).dont_spawn_online = true
--  end

  db.add_obj(self.object)

  -- Все CALLBACK-и ставить здесь:
  self.object:set_patrol_extrapolate_callback(motivator_binder.extrapolate_callback, self)
  self.object:set_callback(callback.hit, motivator_binder.hit_callback, self)
  self.object:set_callback(callback.death, motivator_binder.death_callback, self)
  self.object:set_callback(callback.use_object, motivator_binder.use_callback, self)
  self.object:set_callback(callback_ex.entity_alive_before_hit, self.before_hit_callback, self)
  self.object:set_callback(callback.sound, motivator_binder.hear_callback, self)
  --memusage.collect_info(self.object, "after__callback")

    --' Загрузка историй для лагеря.
  if self.loaded == false then
    local char_ini = self.object:spawn_ini() or ini_file("scripts\\dummy.ltx")
    xr_info.loadInfo(self.object, char_ini)
  end

  if not self.object:alive() then
	self.treasure_processed = true
    return true
  end

  --' Для зомбированных чуваков говорим что аномалий не существует
--  if self.object:character_community() == "zombied" then
    local manager = self.object:motivation_action_manager()
    manager:remove_evaluator  (stalker_ids.property_anomaly)
    manager:add_evaluator   (stalker_ids.property_anomaly, property_evaluator_const(false))
--  end

    --' загрузка озвучки
    --memusage.collect_info(self.object, "before_soundmgr")
    xr_sound.load_sound(self.object)
    --memusage.collect_info(self.object, "after_soundmgr_netspawn_end")

  xr_gulag.setup_gulag_and_logic_on_spawn( self.object, self.st, sobject, modules.stype_stalker, self.loaded )

  -- added by xStream for AMK miniSDK
  amk.on_npc_spawn(self.object)

        amk.on_net_spawn(self.object)
  -- end of addition

        local particle_param = utils.cfg_get_string(sys_ini, self.object:section(), "bones_particles", null, false, false, nil)

        if particle_param and sys_ini:section_exist(particle_param) then
                local tmp=amk.parse_ini_section_to_array(sys_ini,particle_param)

                for k,v in pairs(tmp) do
                        local t = amk.parse_ini_section_to_array(sys_ini, v)
                        t.obj = self.object
                        if not t.stop_on_death or self.object:alive() then
                                play_particle(self.object, t)
                        end
                end
        end

	-- сохранение отношений в Волне
	if level.name() == "zaton" then
		self.npc_goodwill = self.object:goodwill(db.actor)
		if 0 <= self.npc_goodwill and self.npc_goodwill <= 1000 then
			self.npc_goodwill = 1000
		end
		self.com_goodwill = relation_registry.community_goodwill(self.object:character_community(), db.actor:id())
		--get_console():execute("load ~~~ self.object:character_community(): "..self.object:character_community())
		--get_console():execute("load ~~~ self.com_goodwill: "..self.com_goodwill)
	end
		
  -- packet_table.read_packet(self.object) 
    
  return true
end

function motivator_binder:net_destroy()

  if xrs_ai then xrs_ai.npc_net_destroy(self.object) end
  if rx_ai then rx_ai.npc_switch_offline(self.object) end

        if #self.particles > 0 then
                for kk,vv in pairs(self.particles) do
                        if not vv:is_finished() then
                                vv:stop()
                                self.particles[kk]=nil
                        end
                end
        end

  -- added by xStream for AMK miniSDK
  amk.on_npc_go_offline(self.object)
  -- end of addition

  --printf("motivator_binder:net_destroy(): self.object:name()='%s'", self.object:name())
        if self.object == nil then return end

  local st = db.storage[self.object:id()]
  if st.active_scheme then
    xr_logic.issue_event(self.object, st[st.active_scheme], "net_destroy", self.object)
  end

  db.del_obj(self.object)

  db.storage[self.object:id()] = nil

  self:clear_callbacks()
  self.object:set_callback(callback.use_object, nil)

		-- труп исчез из-под носа гг. видимо, воскрес
		if self.rot_sound then
			self.rot_sound = nil
			db.rotting = db.rotting-1
		end

        -- АМК. Очистка рестрикторов
        local id=self.object:id()

  event("npc_net_destroy"):trigger({victim = self.object})
  object_binder.net_destroy(self)

        local sobj=alife():object(id)
        if sobj then
                local tbl=amk.read_stalker_params(sobj)
                tbl.crvu32u16u2={}
                amk.write_stalker_params(tbl,sobj)
        else
                -- Выход из игры.
        end
  -- packet_table.clear_packet(self.object)
end

function motivator_binder:clear_callbacks()
        if self.object == nil then return end
  self.object:set_patrol_extrapolate_callback(nil)
  self.object:set_callback(callback.hit, nil)
  self.object:set_callback(callback.death, nil)
  self.object:set_callback(callback_ex.entity_alive_before_hit, nil)
  self.object:set_callback(callback.sound, nil)
end

function motivator_binder:before_hit_callback(p_s_hit, p_ignore_flags)
	local hit_data = read_hit_data(p_s_hit)
	if hit_data ~= 0 then
		local obj = level.object_by_id(hit_data.who_id)
		if obj then -- если есть виновник хита
			local obj_id = obj:id()
			if obj_id ~= db.actor:id() and IsStalker(obj) then -- если не актор и сталкер
				-- проверяем условия игнорирования урона от дружественного огня
				if  obj_id ~= self.object:id() and -- если не сам себя
					obj:general_goodwill(self.object) >= -100 and -- если друг
					(self.object:relation(obj) ~= game_object.enemy or self.object:character_community() == obj:character_community()) -- and 
--					not xr_companion.is_companion(obj_id)
				then
					-- подстрелил друг, игнорируем
					write_memory_int(1, p_ignore_flags)
				end
--[[
			elseif obj_id == bind_statpkm.pkm_captured and obj:section() == "stationary_pkm" then -- если это турель
				-- то надо заменить на реального виновника, т.е. ГГ
				write_memory_int(db.actor:cast_game_object(), p_s_hit, hit_offset.who)
				write_memory_int16(db.actor:id(), p_s_hit, hit_offset.whoID)
]]
			end
		end
	end
end

function motivator_binder:hit_callback(obj, amount, local_direction, who, bone_index)
	if not self.object then
		self.object = obj
	end
	
	if amount > 0.01 then
		local chk_dist = self.object:position():distance_to(who:position())
		local range = self.object:range()
		if chk_dist > range then
			self.object:set_range(chk_dist*1.1)
		end
		self.object:make_object_visible_somewhen(who)
	end

	kostya_dialog.kuv_hit(who)
-- Akill begin
  akill.on_npc_hit(self, obj, amount, local_direction, who, bone_index)
-- Akill end
  -- FIXME: коллбеки неплохо было бы регистрировать в общем storage, а не посхемно...
  -- просто всегда ставить их при включении схемы и снимать при отключении.

  if self.st.active_section then
    xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "hit_callback", obj, amount, local_direction, who, bone_index)
  end
  if self.st.combat_ignore then
    xr_logic.issue_event(self.object, self.st.combat_ignore, "hit_callback", obj, amount, local_direction, who, bone_index)
  end
  if self.st.combat then
    xr_logic.issue_event(self.object, self.st.combat, "hit_callback", obj, amount, local_direction, who, bone_index)
  end
  if self.st.hit then
    xr_logic.issue_event(self.object, self.st.hit, "hit_callback", obj, amount, local_direction, who, bone_index)
  end
	if amount > 0 then
		sr_territory.issue_event(self.object, "hit_callback", obj, amount, local_direction, who, bone_index)
		if self.object then
			local drop, err_msg = pcall(xr_wounded.hit_callback,self.object:id())
			if not drop then
				log1("ERROR: XR_M xr_wounded.hit_call_back pcall 1 FAIL "..self.object:id().." reason: "..tostring(err_msg))
				db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке коолбэка хита по раненому! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end				
		else
			local drop, err_msg = pcall(xr_wounded.hit_callback,obj:id())
			if not drop then
				log1("ERROR: XR_M xr_wounded.hit_call_back pcall 2 FAIL "..obj:id().." reason: "..tostring(err_msg))
				db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке коолбэка хита по раненому! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end				
		end
	end
	
	local warn_timer = time_global()
	
--	if not ogse.is_quest_npc(obj) and not xr_companion.is_companion(obj:id()) then
		if not warn_check_timer[obj:id()] then
			warn_check_timer[obj:id()] = warn_timer + math.random(1000, 2000) 
		else
			if warn_check_timer[obj:id()] < warn_timer then
				drop, err_msg = pcall(look_to_shot,obj,who)
				if not drop then
					log1("ERROR: XR_M look_to_shot pcall FAIL "..obj:id().." reason: "..tostring(err_msg))
					db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке звука стрельбы! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
				end	
				warn_check_timer[obj:id()] = warn_timer + math.random(1000, 2000)
			end
		end
--	end

    if blowout_scheme then
      blowout_scheme.hit_callback(obj)
    
  end
  
  if rx_ai then rx_ai.npc_hit(obj,amount,local_direction,who,bone_index,self.object) end
  
-- added by xStream for AMK miniSDK
  amk.on_npc_hit(obj, amount, local_direction, who, bone_index)
  -- end of addition

	event("npc_hit"):trigger({victim = self.object, amount = amount, dir = local_direction, who = who, bone = bone_index})
end

function motivator_binder:death_callback(victim, who)
   if self.object == nil then return end
  kostya_dialog.kuv_hit(who)
  if xrs_ai then xrs_ai.npc_death_callback(self.object) end
  if rx_ai then rx_ai.npc_death(self.object,who) end
  xr_statistic.addKillCount(who, self.object)
  if who:id() == db.actor:id() then
		if bind_soul_cube then
			bind_soul_cube.add_soul()
		end
  end

  if self.st.death then
    xr_logic.issue_event(self.object, self.st.death, "death_callback", victim, who)
  end
  if self.st.active_section then
    xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "death_callback", victim, who)
  end
  sr_territory.issue_event(self.object, "death_callback", victim, who)

	local drop, err_msg = pcall(sr_light.check_light,obj)
	if not drop then
		log1("ERROR: XR_M sr_light.check_light pcall FAIL "..victim:id().." reason: "..tostring(err_msg))
		db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке света фонаря после смерти! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
	end	

  smart_terrain.on_death( self.object:id() )

  -- added by xStream for AMK miniSDK
  amk.on_death(victim, who)
  amk_utils.npc_death(victim, who)
  -- end of addition

  death_manager.drop_manager(self.object):create_release_item()

  self:clear_callbacks()

  --' Наносим небольшой импульс вперед.
  local h = hit()
  h.draftsman = self.object
  h.type = hit.fire_wound
  h.direction = db.actor:position():sub(self.object:position())
  h:bone("pelvis")
  h.power = 1
  h.impulse = 10
  self.object:hit(h)

        if #self.particles > 0 then
                for kk,vv in pairs(self.particles) do
                                vv:on_death()
                end
        end

  if(actor_stats.remove_from_ranking~=nil)then
    local community = self.object:character_community()
    if community == "zombied" or
       community == "monolith" or
       community == "arena_enemy"
    then
      return
    end
		local drop, err_msg = pcall(actor_stats.remove_from_ranking,self.object:id())
		if not drop then
			log1("ERROR: XR_DEATH remove_from_ranking pcall FAIL "..victim:id().." reason: "..tostring(err_msg))
			db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой удаления из рангов после смерти! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
		end		
  end

	event("npc_death"):trigger({victim = self.object, who = who})
end

function motivator_binder:use_callback(obj, who)

    if not self.object then 
		if obj then
			self.object = obj
		else	
--			ogse_debug.process_npc(self.object, "use", 0)
			return
		end
	end

  if self.object:alive() then
    xr_use.notify_on_use(obj, who)
    if self.st.active_section then
      xr_logic.issue_event(self.object, self.st[self.st.active_scheme], "use_callback", obj, who)
    end
  else
    if self.treasure_processed == false then
      treasure_manager:get_treasure_manager():use(self.object)
      self.treasure_processed = true
    end
-- 	hotkeys.on_use(obj, who)
	if self.object:name() == "rostok_dead_stalker_0000" then
		db.actor:give_info_portion("acv_vandal")
	end
  end
	if self.object ~= nil then
		if string.find(self.object:section(),"zombie") ~= nil then
			sak.zombie_checkup()
		end
	end

	fly.returner_clear_pos()
	
 -- added by xStream for AMK miniSDK
  amk.on_use(obj, who)
  -- end of addition

	event("npc_used"):trigger({obj = self.object, who = who})
	self.am:call("npc_use", self.object, who)
end

function motivator_binder:update(delta)
    if amk.oau_watchdog~=0 then
        if db.actor and not device():is_paused() then
            local snd_obj = xr_sound.get_safe_sound_object("detectors\\da-2_beep1")
            snd_obj:play_no_feedback(db.actor, sound_object.s2d, 0, vector(), 2.5)
        end
        abort("Watchdog "..amk.oau_watchdog..".Reason "..amk.oau_reason)
    end
    if self.object == nil then return end
    local self_object_id = self.object:id()
    db.storage[self_object_id].us = 100		
    object_binder.update(self, delta)
    db.storage[self_object_id].us = 99
    if particles[self_object_id] and #particles[self_object_id] > 0 then
        for kk,vv in pairs(particles[self_object_id]) do
            self.particles[#self.particles+1] = amk_particle.amk_particle(vv)
            table_remove(particles[self_object_id],kk)
        end
    end

    if #self.particles > 0 then
        for kk,vv in pairs(self.particles) do
            if vv then
                if vv:is_finished() then
                    self.particles[kk]=nil
                else
                    vv:update(delta)
                end
            end
        end
    end

    if self.first_update == false then
        if self.object:alive() == false then
      death_manager.drop_manager(self.object):create_release_item()
        end
        self.first_update = true
    end

    if time_global() - self.last_update > 1000 then
        if amk.get_npc_relation(self.object,db.actor)=="enemy" and self.object:alive() and self.object.health>0.01 then
            if self.object:see(db.actor) then
                amk.enemy_see_actor(self.object,"npc")
            end
            if db.actor:see(self.object) then
                amk.actor_see_enemy(self.object,"npc")
            end
        end
      sr_light.check_light(self.object)

      self.last_update = time_global()
    end

    local wpn = utils.wpn_info_get(self.object)
    if wpn["ammo"]~=nil then
        local enemy = self.object:best_enemy()
        if enemy and enemy:id()==db.actor:id() and self.object:see(db.actor) and self.prev_ammo>wpn["ammo"] then
            amk.npc_shot_actor(self.object)
        end
    end

    self.prev_ammo = wpn["ammo"] or 0

  --' Апдейт менеджера состояний тела
  if self.st.state_mgr then
    if self.object:alive() then
      self.st.state_mgr:update()
      -- Апдейт торговли
      if self.st.state_mgr.combat == false and
         self.st.state_mgr.alife == false
      then
        trade_manager.update(self.object)
      end
    else
      self.st.state_mgr = nil
    end
  end

  --' Апдейт саундменеджера
  if self.object:alive() then
    xr_sound.update(self.object)
  end

  if self.object:alive() then
    if self.object:is_talk_enabled() then
      self.object:set_tip_text("character_use")
    else
      self.object:set_tip_text("")
    end
  else
    self.object:set_tip_text_default()
	-- гниение
	if self.rot then
		self:rotting()
	end
  end

  self.object:info_clear()
  local best_enemy = self.object:best_enemy()
  if best_enemy then
    self.object:info_add('enemy -- ' .. best_enemy:name())
  end
  local active_section = db.storage[self_object_id].active_section
  if active_section then
    self.object:info_add('section -- ' .. active_section)
  end
  self.object:info_add('name -- ' .. self.object:name())

  event("npc_update"):trigger({obj = self.object})

  db.storage[self_object_id].us = 98
  if xrs_ai then xrs_ai.npc_update(self) end
  if rx_ai then rx_ai.npc_update(self.object,self.st) end
  db.storage[self_object_id].us = 0
end

function motivator_binder:reload(section)
  --memusage.collect_info(self.object, "reload_start")
  object_binder.reload(self, section)
  --printf("motivator_binder:reload(): self.object:name()='%s'", self.object:name())
  --self.object:set_pda_callback(pda_callback)
  --memusage.collect_info(self.object, "reload_end")
end

function motivator_binder:net_save_relevant()
  --printf("motivator_binder:net_save_relevant(): self.object:name()='%s'", self.object:name())
  return true
end

function motivator_binder:save(packet)
  printf("motivator_binder:save(): self.object:name()='%s'", self.object:name())
  object_binder.save(self, packet)

  packet:w_bool(self.treasure_processed)

  xr_logic.save_obj(self.object, packet)
  dialog_manager.save(self.object, packet)
  trade_manager.save(self.object, packet)
  
  if self.rot_time == 65535 and not self.object:alive() then
	-- помер, либо гг нашел труп - выставляем время гниения
	self.rot_time = amk.game_hours()+24
  end
  packet:w_u16(self.rot_time)
end

function motivator_binder:load(reader)
  self.loaded = true

  printf("motivator_binder:load(): self.object:name()='%s'", self.object:name())
  object_binder.load(self, reader)
  printf("motivator_binder:object_binder.load(): self.object:name()='%s'", self.object:name())

  if reader:r_eof() then
    --abort("Это сохранение повреждено - удалите его! motivator_binder:load "..self.object:name())
    remove_zavis.remove_obj(self.object)
    if not self.object then
        return
    end
  end

  self.treasure_processed = reader:r_bool()

  xr_logic.load_obj(self.object, reader)
  --dialog_manager.load(self.object, reader)
  self.npc_script_version = alife():object(self.object:id()).script_version
  dialog_manager.load(self.object, reader, self.npc_script_version)
  trade_manager.load(self.object, reader)
  
  if not reader:r_eof() then -- для обратной совместимости
	self.rot_time = reader:r_u16()
  end
end

function motivator_binder:hear_callback(self, who, sound_type, sound_position, sound_power)

--	ogse_debug.process_npc(self, "hr", 1)
	
--[[
	--// xr_companion
	if xr_companion.is_companion(self:id()) then
		ogse_debug.process_npc(self, "hr", 0)
		return
	end	
	
	if who and string.find(who:name(), "vehicle_btr") then
		who = db.actor
	end		
]]

--	ogse_debug.process_npc(self, "hr", 2)	
	
	local snd_timer = time_global()
	
--	ogse_debug.process_npc(self, "hr", 3)
	
	if not snd_check_timer[self:id()] then
		snd_check_timer[self:id()] = snd_timer + math.random(1000, 2000) 
	else
		if snd_check_timer[self:id()] < snd_timer then
			local result, err = pcall(check_sound, self, who, sound_type, sound_position, sound_power)
			if not result then
				log1("ERROR: XR_M hear_callback pcall FAIL "..self:id().." reason: "..tostring(err))
				db.actor:give_game_news("ВНИМАНИЕ! Произошёл сбой при обработке коллбэка звука! В лог поступило диагностическое сообщение - сохранитесь, выйдите из игры и скиньте лог KamikaZze!", "ui\\ui_iconsTotal", Frect():set(498,47,83,47),7000, 20000)
			end
			snd_check_timer[self:id()] = snd_timer + math.random(1000, 2000)
		end
	end
	
	
	
	
--	ogse_debug.process_npc(self, "hr", 0)

end

function motivator_binder:rotting()
	self.pos = self.object:position()
	
	if self.pos:distance_to(db.actor:position()) < 3 then
		if not self.rot_sound then
			self.rot_sound = sound_object([[anomaly\rot_flies]])
			db.rotting = db.rotting+1
		end
		
		if self.rot_sound:playing() then 
			self.rot_sound:set_position(self.pos)
		else
			-- мухи не летают в дождь, ночью и во время Выброса
			if level.rain_factor() < 0.05 and xr_conditions.is_day() and not amk.has_variable("blowout") then
				self.rot_sound:play_at_pos(self.object, self.pos)
			end
		end
	else
		if self.rot_sound then
			self.rot_sound = nil
			db.rotting = db.rotting-1
		end
	end
end

function AddToMotivator(npc)
  if alife() then
    npc:bind_object(this.motivator_binder(npc))
  end
end

-- Эвалюаторы, которые имеют высший приоритет, и, соответственно, перебивают остальные скрипты собой
function addCommonPrecondition(action)
  --action:add_precondition (world_property(xr_evaluators_id.reaction,false))
  action:add_precondition (world_property(xr_evaluators_id.stohe_meet_base + 1,false))
  action:add_precondition (world_property(xr_evaluators_id.sidor_wounded_base + 0,  false))
  action:add_precondition (world_property(xr_evaluators_id.chugai_heli_hunter_base, false))
  action:add_precondition (world_property(xr_evaluators_id.abuse_base, false))
  action:add_precondition (world_property(blowout_scheme.evid_outside, false))
  action:add_precondition (world_property(blowout_scheme.evid_blowout, false))
  action:add_precondition (world_property(blowout_scheme.evid_preblowout, false))
  action:add_precondition(world_property(blowout_scheme.evid_anomaly, false))
  if ricochet_scheme then
    action:add_precondition(world_property(ricochet_scheme.evid_ricochet_danger, false))
  end
        if watcher_act then
    action:add_precondition(world_property(watcher_act.evid_see_stuff, false))
        end

  if xrs_ai then xrs_ai.addCommonPrecondition(action) end
  if rx_ai then rx_ai.addCommonPrecondition(action) end

end

function play_particle(obj,params)
    if obj then
        local id = obj:id()
        if not particles[id] then
                particles[id]={}
        end
        particles[id][#particles[id]+1] = params
    end
end
