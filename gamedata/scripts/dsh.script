-- -*- mode: lua; coding: windows-1251-dos -*-

class "timeout_timer" ( ogse_qt.quick_timer )
function timeout_timer:__init( delay, fun) super( delay )
	self.fun = fun
end
function timeout_timer:taction()
  self.fun()
end

function timeout( delay, fun )
  local tmout = timeout_timer( delay, fun )
  tmout:start()
  return tmout
end


function op2quicksave()
  db.op2_save_compat = true
  local bad_infos = {
    "first_blowout",
    "ogse_DEBUG_relations_cleared",
  }
  local restore_infos = {}
  for _, info in ipairs( bad_infos ) do
    if db.actor:has_info( info ) then
      table.insert( restore_infos, info )
      db.actor:disable_info_portion( info )
    end
  end
  local incompat_slots = { 8, 11, 12 }
  for _, slot in ipairs( incompat_slots ) do
    local s_item = db.actor:item_in_slot( slot ) -- есть ли в этом слоте что-то
    if s_item then
      db.actor:move_to_ruck( s_item )
    end
  end
  local incompat_belt_items = {
    [ "acumm" ] = true,
  }
  local remove_from_belt = {}
  for i = 0, db.actor:belt_count() - 1 do
    local item = db.actor:item_on_belt( i )
    if incompat_belt_items[ item:section() ] then
      table.insert( remove_from_belt, item )
    end
  end
  for _, k in ipairs( remove_from_belt ) do
    db.actor:move_to_ruck( k )
  end
  amk.del_variable( "blow_started" )
  cmd( "save", "op2quicksave" )
  for _, info in ipairs( restore_infos ) do
    db.actor:give_info_portion( info )
  end
  db.op2_save_compat = false
end


function set_condition( item, cond )
  item:set_condition( cond )
  local sobj = alife():object( item:id() )
  if sobj then
    local tbl = amk.get_item_params( sobj )
    tbl.condition = cond
    amk.set_item_params( tbl, sobj )
  end
end


-- взято из http://www.amk-team.ru/forum/index.php?showtopic=6458&p=937442
--[[

local lname = level.name()
local lvtab = GetLevelVertexes( lname )
local lvx = math.max( unpack( lvtab ) )
local lv  = math_random( 1, lvx ) --//рандомный левел-вертекс

local gvtab  = GetGameVertexes( lname )
local gv_min = math.min( unpack( gvtab ) )
local gv_max = math.max( unpack( gvtab ) )

]]
function GetLevelVertexes( level )
  local lvtab ={}
  local i = 0
  while game_graph():valid_vertex_id( i ) do  
    local lv = game_graph():vertex( i ):level_vertex_id() 
    local ln = alife():level_name( game_graph():vertex( i ):level_id() ) 
    if not lvtab[ ln ] then 
      lvtab[ ln ] = {}  
    end       
    table.insert( lvtab[ ln ], lv )
    i = i + 1
  end
  return lvtab[ level ]
end

function GetGameVertexes( level )
  local gvtab ={}
  local i = 0
  while game_graph():valid_vertex_id( i ) do
    local ln = alife():level_name( game_graph():vertex( i ):level_id() )
    if not gvtab[ ln ] then
      gvtab[ ln ] = {}
    end
    table.insert( gvtab[ ln ], i )
    i = i + 1
  end
  return gvtab[ level ]
end


function is_enemy_around()
  for id in pairs( db.creature ) do
    if id then
      local obj = level.object_by_id( id )
      if obj and obj:is_custom_monster() and obj:alive() then
        local is_stalker = IsStalker(obj)
        local dist = obj:position():distance_to( db.actor:position() )
        local is_enemy_to_actor =
          ogse.get_npc_relation( obj, db.actor ) == "enemy"
        if
          ( ( is_stalker and is_enemy_to_actor ) or IsMonster( obj ) )
          and
          ( dist < 5 or obj:see( db.actor ) )
        then
          return true
        end
      end
    end
  end
  return false
end	
