-----------------------------------------------------------------------
--- ui_item_effects.script
--- Модуль отображения ножей и биноклей в слотах, работы с фейк-предметами
--- FEAR93, Dusty79, Malandrinus (c) OGS Evolution Team
--- version 6.0 (30/08/2011)
-----------------------------------------------------------------------
function attach(sm)
	sm:subscribe({signal = "on_spawn",          fun = this.on_spawn})
	sm:subscribe({signal = "on_inventory_open", fun = this.on_inventory_open})
	sm:subscribe({signal = "on_inventory_hide", fun = this.on_inventory_hide})
	sm:subscribe({signal = "on_item_to_ruck",   fun = this.on_item_to_ruck})
end

local sim

local slots_wnd

function on_spawn() -- при появлении актора проинитить используемые в будущем глобальные переменные
	sim = alife()
end

-- Открытие/закрытие инвентаря

function on_inventory_open()
   -- конвертируем все предметы в их фейковые эквиваленты
   local ids = {}
   for i = 0, db.actor:ruck_count() - 1 do
      local it = db.actor:item_in_ruck(i)
      local res = convert_item_to_fake_in_inventory(it)
      if res then table.insert(ids, it:id()) end
   end
   if #ids > 0 then
      level.disable_input()
      wait_for_deleted_objects_to_disappear(ids):start()
   end
end

class "wait_for_deleted_objects_to_disappear" (ogse_qt.quick_timer)
function wait_for_deleted_objects_to_disappear:__init(ids) super()
	self.ids = ids
end
function wait_for_deleted_objects_to_disappear:condition()	
	-- начать перебирать список
	-- если объект существует, прекратить, вернуть false
	-- иначе - удалить объект из списка и перейти к следующему
	-- если объектов больше нет, вернуть true
	while #self.ids > 0 do
		local obj = level.object_by_id(self.ids[1])
		if obj then return false end
		table.remove(self.ids, 1)
	end
	return true
end
function wait_for_deleted_objects_to_disappear:action()
	level.enable_input() 
end
function on_inventory_hide()
	-- конвертируем все фейки обратно в реальные предметы
	local ids = {}
	for i = 0, db.actor:ruck_count() - 1 do
		local it = db.actor:item_in_ruck(i)
		local res = convert_fake_to_item_in_inventory(it)
		if res then table.insert(ids, it:id()) end
	end
	if #ids > 0 then 
		level.disable_input()
		wait_for_deleted_objects_to_disappear(ids):start()
	end
end

function convert_item_to_fake_in_inventory(item)
	if item == nil or sim:object(item:id()) == nil then return false end
	local sect = item:section()
	local fake_obj_section = get_string(sect, "fake_item_section")
	if fake_obj_section and fake_obj_section ~= sect then
		return recreate_transfer_data(item, fake_obj_section)
	end
	return false
end

function convert_fake_to_item_in_inventory(item)
	if item == nil or sim:object(item:id()) == nil then return false end
	local sect = item:section()
	local real_obj_section = get_string(sect, "real_item_section")
	if real_obj_section and real_obj_section ~= sect then
		return recreate_transfer_data(item, real_obj_section)
	end
	return false
end

function recreate_transfer_data(obj_to_del, sec_to_create)
	local sobj = sim:object(obj_to_del:id())
	if not sobj then return false end
	-- не совсем верно проверять по секции создаваемого, 
	-- но при правильной настройке оба (и удаляемый и создаваемый) должны иметь параметр "is_shotgun" или оба не иметь
	if get_u32(sec_to_create, "is_shotgun") == 1 then
		-- заменяем на систему xStream
		--local pk1 = xs_netpk.net_alife_item(sobj)
		--ASSERT(pk1:isOk(), "[recreate_transfer_data] cannot get netpacket for the object '%s'", sobj:get_name())
		--local data = pk1:get()
		--data.health = health
		--data.updhealth = health
		--pk:set(data)

		local t1 = m_net_utils.get_item_data(sobj)
		local s_fake_item = ogse.spawn_item_in_inv(sec_to_create)
		local t2 = m_net_utils.get_item_data(s_fake_item)
		t2.custom = t1.custom
		m_net_utils.set_item_data(t2,s_fake_item)
	else
		ogse.spawn_item_in_inv(sec_to_create)
	end
	sim:release(sobj, true)
	return true
end

function on_item_to_ruck(obj, sobj)	-- обработка всех полученных фейк-предметов при открытом инвентаре
	if db.actor:dont_has_info("ui_inventory") then return end
	if not sobj then return end
	ASSERT(obj, "ogse_ui_item_effects.on_item_to_ruck: obj is a nil reference")
	ASSERT(sobj, "ogse_ui_item_effects.on_item_to_ruck: sobj is a nil reference, name="..obj:name())
	local sec = obj:section()
	local fake_item_section = get_string(sec, "fake_item_section")
	if not fake_item_section then return end
	convert_item_to_fake_in_inventory(obj)
	return true
end
