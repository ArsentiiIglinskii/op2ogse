-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_monster_death",  fun = this.on_monster_death })
  sm:subscribe({ signal = "on_monster_net_destroy", fun = this.on_monster_death })
end


function create_radius( obj, home_radius, home_vertex, onetime )
  local binder = obj:binded_object()
  local mgr    = battle_radius( obj, home_radius, home_vertex, onetime )
  binder[ "dsh_battle_radius.mgr" ] = mgr
  local subscribed = {
    [ "signal" ] = "on_monster_update." .. obj:id(),
    [ "self"   ] = mgr,
    [ "fun"    ] = mgr.update,
  }
  ogse_signals.get_mgr():subscribe( subscribed )
  mgr.subscribed = subscribed
  return mgr
end


function on_monster_death( obj )
  local binder = obj:binded_object()
  local mgr    = binder[ "dsh_battle_radius.mgr" ]
  if not mgr then return end
  ogse_signals.get_mgr():unsubscribe( mgr.subscribed )
  binder[ "dsh_battle_radius.mgr" ] = nil
end


local STATE_ALIFE     = 1
local STATE_MOVE_HOME = 2


class "battle_radius"
function battle_radius:__init( obj, home_radius, home_vertex, onetime )
  self.home_radius = home_radius
  self.home_vertex = home_vertex
  self.initialized = false
  self.object      = obj
  self.onetime     = onetime
end


function battle_radius:reset_scheme()
  self.state_current = STATE_ALIFE
  self.state_prev    = self.state_current
  xr_logic.mob_release( self.object )
end


function battle_radius:update( obj )
  self.object = obj
  if not self.object:alive() then return end
  if not self.initialized then
    self:reset_scheme()
    self.initialized = true
  end
  self:select_state()
  self:execute_state()
end


function battle_radius:select_state()
  self.state_prev = self.state_current

  local home_node = self.home_vertex or db.actor:level_vertex_id()
  ASSERT(
    home_node,
    "[%s]: %s: home_node = %s, self.home_vertex = %s",
    script_name(), self.object:name(), tostring( home_node ),
    tostring( self.home_vertex )
  )
  if not self.object:accessible( home_node ) then
    local vtemp = vector():set( 0, 0, 0 )
    home_node, vtemp = self.object:accessible_nearest(
      level.vertex_position( home_node ), vtemp
    )
  end
  self.home_node     = home_node
  self.home_position = level.vertex_position( self.home_node )

  local enemy     = self.object:best_enemy()
  local home_dist = self.object:position():distance_to( self.home_position )
  if
    (
      enemy
      and ( IsStalker( enemy ) or ( self.onetime and IsMonster( enemy ) ) )
      and enemy:alive()
    )
    or (
      home_dist < self.home_radius
      and (
        ( not self.home_min_radius )
        or (
          self.state_current == STATE_MOVE_HOME
          and home_dist < self.home_min_radius
        )
      )
    )
  then
    self.state_current = STATE_ALIFE
  else
    self.state_current = STATE_MOVE_HOME
  end
end


function battle_radius:execute_state()
  if self.state_current == STATE_ALIFE and self.state_prev == STATE_ALIFE then
    return
  end

  if self.state_current == STATE_ALIFE and self.state_prev ~= STATE_ALIFE then
    xr_logic.mob_release( self.object )
    if self.onetime then
      on_monster_death( self.object )
    end
    local sobj = alife():object( self.object:id() )
    if sobj then
      sobj.force_online = false
    end
    return
  end

  if self.state_current ~= STATE_ALIFE and self.state_prev == STATE_ALIFE then
    xr_logic.mob_capture( self.object, true )
    local sobj = alife():object( self.object:id() )
    if sobj then
      sobj.force_online = true
    end
  end

  if self.state_current == STATE_MOVE_HOME then
    if not self.object:action() then
      action(
        self.object,
        move( move.run_fwd, self.home_node, self.home_position ),
        cond( cond.move_end )
      )
    end
  end
end
