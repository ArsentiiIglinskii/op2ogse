-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({
    signal = "on_actor_weapon_fire", fun = this.on_actor_weapon_fire
  })
  sm:subscribe({
    signal = "on_actor_weapon_reload", fun = this.on_actor_weapon_reload
  })
  sm:subscribe({
    signal = "on_actor_weapon_start_firing",
    fun    = this.on_actor_weapon_start_firing,
  })
  sm:subscribe({
    signal = "on_actor_weapon_switch_gl",
    fun    = this.on_actor_weapon_switch_gl,
  })
  sm:subscribe({
    signal = "on_actor_weapon_zoom_in",
    fun    = this.on_actor_weapon_zoom_in,
  })
  sm:subscribe({
    signal = "on_actor_weapon_zoom_out",
    fun    = this.on_actor_weapon_zoom_out,
  })
  sm:subscribe({ signal = "on_inventory_hide", fun = this.on_inventory_hide })
  sm:subscribe({ signal = "on_key_down",   fun = this.on_key_down })
  sm:subscribe({ signal = "on_throw_grenade", fun = this.on_throw_grenade })
end


function on_spawn()
end


local stand_power = get_float( "actor_condition", "stand_power" )
local time_factor = get_float( "alife", "time_factor" )


local cur_wpn = {}
function get_wpn_info( wpn )
  local t = cur_wpn
  if ( not t.name ) or t.name ~= wpn:name() then
    t.binded           = wpn:binded_object()
    t.check_silencer   = get_bool(
      wpn:section(), "dsh_wpn.check_silencer", true
    )
    t.const_dev_t      = 0
    t.dispersion_start = get_u32( wpn:section(), "dispersion_start" )
    t.fire_dispersion_base = get_float(
      wpn:section(), "fire_dispersion_base", 0
    )
    t.fire_power_loss  = get_fire_power_loss( wpn )
    t.gl_mode          = nil
    t.gl_name          = nil
    t.has_gl           = nil
    t.has_silencer     = nil
    t.highfire_mode    = get_u32( wpn:section(), "highfire_mode" )
    t.hit_power        = get_float( wpn:section(), "hit_power"   )
    t.hit_power_2      = get_float( wpn:section(), "hit_power_2" )
    t.id               = wpn:id()
    t.inv_weight       = get_float( wpn:section(), "inv_weight", 0 )
    t.is_knife         = wpn:is_knife()
    t.lowfire_mode     = get_u32( wpn:section(), "lowfire_mode"  )
    t.name             = wpn:name()
    t.queue_size       = nil
    t.rpm              = get_u32( wpn:section(), "rpm"      )
    t.rpm_high         = get_u32( wpn:section(), "rpm_high" )
    t.rpm_low          = get_u32( wpn:section(), "rpm_low"  )
    t.silencer_mode    = nil
    t.use_aim_bullet   = get_bool( wpn:section(), "use_aim_bullet", false )
    t.wpn              = wpn
    t.zoom_body_state  = "unknown"
    t.zoom_enabled     = get_bool( wpn:section(), "zoom_enabled", true )
  end
  if t.has_gl == nil then
    t.has_gl = has_wpn_gl( wpn )
    if t.has_gl then
      t.gl_mode = ogse_wpn_utils.get_gl_mode( wpn )
      t.gl_name = get_string( wpn:section(), "grenade_launcher_name" )
    end
  end
  if t.check_silencer and t.has_silencer == nil then
    t.has_silencer = ( ogse_wpn_utils.get_silencer_status( wpn ) == 2 )
  end
  return cur_wpn
end


function get_fire_power_loss( wpn )
  local sect = wpn:section()
  local fire_power_loss_k = get_float( sect, "dsh_wpn.fire_power_loss_k", 1 )
  return stand_power * time_factor * fire_power_loss_k
end


function has_wpn_gl( wpn )
  return (
    wpn:is_weapon_gl()
    and (
      ogse_wpn_utils.get_grenade_launcher_status( wpn ) == 1
      or (
        ogse_wpn_utils.get_grenade_launcher_status( wpn ) == 2
        and ogse_wpn_utils.get_grenade_launcher_flag( wpn )
      )
    )
  )
end


function check_silencer( cur_wpn )
  if not cur_wpn.has_silencer then return end
  local wpn           = cur_wpn.wpn
  local silencer_mode = ogse_wpn_utils.get_silencer_flag( wpn )
  if cur_wpn.silencer_mode ~= silencer_mode then
    local def_condition_shot_dec = get_float(
      wpn:section(), "condition_shot_dec"
    )
    if silencer_mode then
      local cond_shot_dec = def_condition_shot_dec * 4
      ogse_wpn_utils.set_condition_shot_dec( wpn, cond_shot_dec )
    else
      ogse_wpn_utils.set_condition_shot_dec( wpn, def_condition_shot_dec )
    end
    cur_wpn.silencer_mode = silencer_mode
  end
end


function configure_high_rpm( cur_wpn )
  if cur_wpn.highfire_mode then
    local wpn = cur_wpn.wpn
    local qs  = ogse_wpn_utils.get_queue_size( wpn )
    if ( not cur_wpn.queue_size ) or qs ~= cur_wpn.queue_size then
      local rpm
      if qs == cur_wpn.highfire_mode then
        rpm = 60 / cur_wpn.rpm_high
      else
        rpm = 60 / cur_wpn.rpm
      end
      ogse_wpn_utils.set_time_to_fire( wpn, rpm )
      cur_wpn.queue_size = qs
    end
  end
end


function configure_low_rpm( cur_wpn )
  if cur_wpn.lowfire_mode and cur_wpn.lowfire_mode > 1 then
    local wpn = cur_wpn.wpn
    -- уменьшать время выстрела нужно не после последнего выстрела, а после
    -- предпоследнего, т.к. движок уже вычислил время ожидания и новое время
    -- выстрела вступит в силу только через выстрел.
    local shot_n = wpn:get_weapon_m().shot_num
    if shot_n == 0 then
      ogse_wpn_utils.set_time_to_fire( wpn, 60 / cur_wpn.rpm )
    elseif shot_n == cur_wpn.lowfire_mode - 1 then
      ogse_wpn_utils.set_time_to_fire( wpn, 60 / cur_wpn.rpm_low )
    end
  end
end


local def_disp_aim = get_float( "actor", "disp_aim" )

function configure_fire_dispersion( cur_wpn )
  local zoom_bs = get_zoom_body_state()
  if cur_wpn.zoom_body_state ~= zoom_bs then
    local k = zoom_bs == "zoom_crouch" and 0.5
      or ( zoom_bs == "zoom_creep" and 0.25 )
      or 1
    set_disp_aim( math.rad( def_disp_aim * k ) )
    if cur_wpn.use_aim_bullet and cur_wpn.wpn:condition() > 0.9 then
      ogse_wpn_utils.set_fire_dispersion_base(
        cur_wpn.wpn, math.rad( cur_wpn.fire_dispersion_base * k )
      )
    end
    cur_wpn.zoom_body_state = zoom_bs
  end
end


function get_zoom_body_state()
  local aobj = get_actor_obj()
  return zoom_mode()
    and (
      aobj:is_actor_crouch()
        and "zoom_crouch"
        or (
          aobj:is_actor_creep() and "zoom_creep"
        )
        or "zoom_normal"
    )
    or "no_zoom"
end


function on_actor_weapon_start_firing( wpn )
  local cur_wpn = get_wpn_info( wpn )
  -- configure_high_rpm( cur_wpn )
  configure_low_rpm( cur_wpn )
  -- configure_fire_dispersion( cur_wpn )
  check_silencer( cur_wpn )
  configure_const_dev( cur_wpn )
end


local knife_anim_length = {}
local knife_fire_t

function on_actor_weapon_fire( wpn )
  local t = get_wpn_info( wpn )
  configure_low_rpm( t )
  local fire_power_loss = t.fire_power_loss
  if fire_power_loss >= 0 then return end
  if t.is_knife then
    local sect = wpn:section()
    if not knife_anim_length[ sect ] then
      knife_anim_length[ sect ] = {}
    end
    local power_loss_weight = fire_power_loss * (
      t.inv_weight > 1 and inv_weight or 1
    )
    local max_power_loss = 0
    local state          = wpn:get_hud_item_state()
    if state == weapon_states.fire2 then
      max_power_loss = fire_power_loss * ( t.hit_power_2 / t.hit_power )
    end
    if knife_fire_t then knife_fire_t:stop() end
    local anim_len = knife_anim_length[ sect ][ state ]
    if anim_len then
      knife_fire_t = dsh.timeout( anim_len / 2, function()
        db.actor.power = power_loss_weight + max_power_loss
        knife_fire_t   = nil
      end )
    else
      db.actor.power = power_loss_weight + max_power_loss
      local name   = t.name
      local fire_t = time_global()
      knife_fire_t = dsh.wait_condition(
        function()
          local item = db.actor:active_item()
          return not (
            item and item:name() == name
            and item:get_hud_item_state() == state
          )
        end,
        function()
          local item = db.actor:active_item()
          if item and item:name() == name then
            knife_anim_length[ sect ][ state ] = time_global() - fire_t
          end
          knife_fire_t = nil
        end
      )
    end
  else
    local zoom_bs = t.zoom_body_state
    local k       = ( zoom_bs == "zoom_crouch" and 0.75  )
      or ( zoom_bs == "zoom_creep" and 0.5 ) or 1
    db.actor.power = fire_power_loss * k
  end
end


local grenade_throwing_t

function on_key_down( key, bind )
  if
    bind ~= key_bindings.kWPN_ZOOM
    or db.actor:active_slot() ~= 3
  then
    return
  end
  local item = db.actor:active_item()
  if item and item:is_grenade() then
    grenade_throwing_t = time_global()
  end
end


function on_throw_grenade( obj )
  local fire_power_loss = get_fire_power_loss( obj )
  local max_power_loss  = 0
  if grenade_throwing_t then
    local sect        = obj:section()
    local force_max   = get_float( sect, "force_max" )
    local force_min   = get_float( sect, "force_min" )
    local force_speed = get_float( sect, "force_grow_speed" )
    local max_t = ( force_max - force_min ) / force_speed * 1000
    local t     = time_global() - grenade_throwing_t
    if t > max_t then t = max_t end
    max_power_loss     = fire_power_loss * 3 * ( t / max_t )
    grenade_throwing_t = nil
  end
  db.actor.power = fire_power_loss + max_power_loss
end


function check_hidden_ammo( cur_wpn )
  if
    not (
      cur_wpn.has_gl and cur_wpn.binded and cur_wpn.binded.has_gl.loaded
    )
  then
    return
  end
  cur_wpn.binded:check_hidden_ammo()
  cur_wpn.binded.has_gl.loaded = false
end


function on_inventory_hide()
  cur_wpn.has_gl       = nil
  cur_wpn.has_silencer = nil
end


function on_actor_weapon_reload( wpn )
  local aobj = get_actor_obj()
  if not ( aobj:is_actor_sprinting() or aobj:is_actor_climbing() ) then
    return
  end
  local active_slot = db.actor:active_slot()
  local drop        = level.get_game_difficulty() * 0.2
  if dsh.small_wpn_slots[ active_slot ] then
    drop = drop * 0.5
  end
  if math.random() < drop then
    db.actor:drop_item( wpn )
    dsh.say_blin()
  end
end


function calc_const_dev()
  local  max = 0.15
  -- от -max до max
  return max * math.random() * 2 - max
end

local apply_const_dev = true
function configure_const_dev( t )
  if
    not (
      apply_const_dev and t.zoom_enabled and t.wpn:is_weapon_magazined()
    )
  then
    return
  end
  if t.const_dev_t < time_global() then
    local wpn = t.wpn:get_weapon()
    wpn.const_deviation.pitch = calc_const_dev()
    wpn.const_deviation.yaw   = calc_const_dev()
    t.const_dev_t = time_global() + math.random( 1000, 10000 )
  end
end


function on_actor_weapon_zoom_in( obj )
  apply_const_dev = false
  if not obj:is_weapon_magazined() then return end
  local wpn = obj:get_weapon()
  wpn.const_deviation.pitch = 0
  wpn.const_deviation.yaw   = 0
  local t = get_wpn_info( obj )
  t.const_dev_t = time_global()
  ezi_startup( t )
end


local snd_breathout = sound_object( "actor\\breathout" )
local ezi_t         = false

function ezi_startup( t )
  if ezi_t then ezi_t:stop() end
  local aobj, wpn = get_actor_obj(), t.wpn
  local breathout, breathout_t = false
  local ezi, disp_k, disp_min
  ezi_t = dsh.wait_condition(
    function( timer )
      if not db.actor:zoom_mode() then return true end
      if wpn_IsRotatingToZoom( wpn ) then
        return
      else
        if not ezi then
          ezi = find_effector_zi()
          if not ezi then return true end
          disp_k   = ezi.zoom_aim_disp_k
          disp_min = ezi.disp_min
          if disp_min == 0 and disp_k == 0 then return true end
        end
        if not breathout_t then breathout_t = time_global() + 10000 end
      end
      local need_breathout = false
      if aobj:is_actor_creep() then
        ezi.disp_min = 0
      elseif aobj:is_actor_crouch() then
        if breathout_t > time_global() then
          ezi.disp_min   = 0
        else
          ezi.disp_min   = disp_min / 2
          need_breathout = true
        end
      else
        local health_k = 1 - db.actor.health / 0.9
        local power_k  = 1 - db.actor.power  / 0.8
        local cond_k   = math.max( health_k, power_k )
        if cond_k <= 0 then
          if breathout_t > time_global() then
            ezi.disp_min   = 0
          else
            ezi.disp_min   = disp_min
            need_breathout = true
          end
        else
          need_breathout = ( ezi.disp_min == 0 )
          ezi.disp_min   = disp_min + disp_min * cond_k
        end
      end
      if need_breathout and not breathout then
        breathout = true
        snd_breathout:play( db.actor, 0, sound_object.s2d )
      end
      timer:reschedule( 500 )
    end,
    function() ezi_t = false end
  )
  ezi_t:set_script_name( "dsh_wpn.ezi_startup" )
end


function on_actor_weapon_zoom_out( obj )
  apply_const_dev = true
  if ezi_t then
    ezi_t:stop()
    ezi_t = false
  end
end


function on_actor_weapon_switch_gl( obj, gl_mode )
  local t = get_wpn_info( obj )
  t.gl_mode = gl_mode
  check_hidden_ammo( t )
  if not zoom_mode() then return end
  local slot = db.actor:active_slot()
  db.actor:activate_slot( NO_ACTIVE_SLOT )
  db.actor:activate_slot( slot )
end


function bind( obj )
  obj:bind_object( wpn_binder( obj ) )
end


class "wpn_binder"( object_binder )
function wpn_binder:__init( obj ) super( obj )
  self.has_gl = {}
  self.has_gl.loaded = false
end


function wpn_binder:net_save_relevant()
  return true
end


function wpn_binder:reinit()
  self.object:set_callback(
    callback.on_addon_init, self.init_addons, self
  )
  self.object:set_callback(
    callback.update_addons_visibility, self.update_addons_visibility, self
  )
end


function wpn_binder:net_destroy()
  self.object:set_callback( callback.on_addon_init, nil )
  self.object:set_callback( callback.update_addons_visibility, nil )
end


function wpn_binder:init_addons( a )
  if a == 1 and self.object:is_weapon_gl() then return end
  ogse_wpn_utils.activate_visibility_updates( self.object, true )
end


function wpn_binder:update_addons_visibility()
  if not self.has_gl.loaded then return end
  if has_wpn_gl( self.object ) then return end
  -- подствольник сняли
  if self.has_gl.gl_mode then
    self:check_hidden_ammo()
  end
  self.has_gl.loaded = false
end


function wpn_binder:check_hidden_ammo()
  local cur_t    = ogse_wpn_utils.get_active_ammo_type( self.object )
  local hidden_t = self.has_gl.hidden_t
  if cur_t == hidden_t then return false end
  local ammo_class = parse_names(
    get_string(
      self.object:section(),
      ( self.has_gl.gl_mode and "ammo_class" or "grenade_class" )
    )
  )
  local ammo     = ammo_class[ hidden_t + 1 ]
  local hidden_n = self.has_gl.hidden_n
  log2(
    "[%s]: wrong hidden ammo detected for %s, returning %s (%s)",
    script_name(), self.object:name(), ammo, hidden_n
  )
  self.object:set_ammo_elapsed( 0 )
  se_respawn.create_ammo(
    ammo, vector():set( 0, 0, 0 ), 1, 1, db.actor:id(), hidden_n
  )
  return true
end


function wpn_binder:load( packet )
  object_binder.load( self, packet )
  if packet:r_eof() then return end
  local has_gl = packet:r_bool()
  if has_gl then
    self.has_gl.gl_mode  = packet:r_bool()
    self.has_gl.hidden_t = packet:r_u8()
    self.has_gl.hidden_n = packet:r_u8()
    self.has_gl.loaded   = true
  end
end


function wpn_binder:save( packet )
  ASSERT(
    not db.saving_obj,
    "found saving_obj = %s",
    tostring( db.saving_obj and db.saving_obj:name() or nil )
  )
  db.saving_obj = self.object
  object_binder.save( self, packet )
  local has_gl = has_wpn_gl( self.object )
  packet:w_bool( has_gl )
  if has_gl then
    local gl_mode, hidden_t, hidden_n
    if self.has_gl.loaded then
      gl_mode  = self.has_gl.gl_mode
      hidden_t = self.has_gl.hidden_t
      hidden_n = self.has_gl.hidden_n
    else
      gl_mode  = ogse_wpn_utils.get_gl_mode( self.object )
      hidden_t = ogse_wpn_utils.get_hidden_ammo_type( self.object )
      hidden_n = ogse_wpn_utils.get_ammo_elapsed2( self.object )
    end
    packet:w_bool( gl_mode  )
    packet:w_u8(   hidden_t )
    packet:w_u8(   hidden_n )
  end
  db.saving_obj = false
end
