-- -*- mode: lua; coding: windows-1251-dos -*-

local DIST_TO_ACTOR =  4 -- 2^2
local DIST_TO_NPC   = 16 -- 4^2
local SCAN_TIME     = 5000

local exclude_flames = {
  -- [ "zone_flame_small_kamin" ] = true, -- камин рядом со Свибловым
}


function attach(sm)
  sm:subscribe({
    signal = "on_before_actor_conditions_update",
    fun    = this.actor_conditions_update
  })
  sm:subscribe({ signal = "on_update", fun = this.on_actor_update })
end
auto_attach = true


local flames = {}
local lights = {}
local looking_into_flame = false
local prev_actor_pos
local start_stand_time   = time_global()


function on_actor_update()
  ogse_signals.get_mgr():reschedule( 1000 )
  if not prev_actor_pos then prev_actor_pos = db.actor:position() end
  if prev_actor_pos:distance_to_sqr( db.actor:position() ) > 0.01 then -- 0.1^2
    start_stand_time = time_global()
  end
  prev_actor_pos     = db.actor:position()
  looking_into_flame = false
  if db.actor.psy_health < 1 and stand_time() > 3000 then
    local npos = device().cam_pos
    local pos  = get_nearest_flame_pos( npos, 3 )
    if pos then
      local diff  = vector():sub( pos, npos ):normalize()
      local vd    = device().cam_dir
      local cp    = vector():crossproduct( vd, diff )
      local dp    = vd:dotproduct( diff )
      local angle = math.atan2( cp:magnitude(), dp )
      if math.abs( angle ) < 0.75 then
        looking_into_flame = true
      end
    end
  end
end


function get_nearest_flame_pos( npos, dist )
  for _, campfire in pairs( flames ) do
    local pos = campfire.object:position()
    local d   = pos:distance_to( npos )
    if d <= dist then
      if campfire.flame_enabled then return pos end
    end
  end
end


function actor_conditions_update( ext )
  if looking_into_flame then
    ext.psy_health_restore_speed = ext.psy_health_restore_speed + 0.006
  end
end


function stand_time()
  return time_global() - start_stand_time
end


function bind_unknown_light( obj )
  obj:bind_object( unknown_light_binder( obj ) )
end


class "unknown_light_binder" ( object_binder )
function unknown_light_binder:__init( obj ) super( obj )
end


function unknown_light_binder:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then
    return false
  end
  lights[ self.object:level_vertex_id() ] = self.object:id()
  return true
end


function unknown_light_binder:net_destroy()
  lights[ self.object:level_vertex_id() ] = nil
  object_binder.net_destroy( self )
end


function bind_flame( obj )
  if exclude_flames[ obj:name() ] then return end
  obj:bind_object( campfire_binder( obj ) )
end


-- типа конечный автомат:
--   next - переводит КА в следующее состояние
--     action - вызывается при переходе в данное состояние
states = {
  -- костер полностью погашен: аномалия отключена, лампа погашена,
  -- партиклы не играют
  turn_off = {
    next = function( has_users, now, prev )
      if has_users then
        return states.firing
      else
        return states.turn_off
      end
    end,
    action = function( self )
      self:switch_flame( false )
      if self.particle then self.particle:stop() end
      self:switch_light( false )
    end,
  },

  -- костер горит на полную: аномалия включена, лампочка горит, партиклов нет
  firing = {
    next = function( has_users, now, prev )
      if has_users or prev + 300000 > now then
        return states.firing
      else
        return states.down
      end
    end,
    action = function( self )
      self:switch_flame( true )
      self:switch_light( true )
      if self.particle then self.particle:stop() end
    end,
  },

  -- костер начинает гаснуть: аномалия еще включена, лампочка горит,
  -- включается партикл затухающего огня
  down = {
    next = function( has_users, now, prev )
      if has_users then
        return states.firing
      elseif prev + SCAN_TIME < now then
        return states.flame_off
      else
        return states.down
      end
    end,
    action = function( self )
      self:switch_flame( true )
      self:switch_light( true )
      if not self.particle then
        self.particle = particles_object( "dyn_kfire\\dyingfire" )
      end
      self:play_particle_near_light()
    end,
  },

  -- следующий этап угасания: отключается аномалия, но лампочка еще горит,
  -- партикл играется
  flame_off = {
    next = function( has_users, now, prev )
      if has_users then
        return states.firing
      elseif prev + 32000 < now then
        return states.turn_off
      else
        return states.flame_off
      end
    end,
    action = function( self )
      self:switch_flame( false )
      self:switch_light( true  )
      if not self.particle then
        self.particle = particles_object( "dyn_kfire\\dyingfire" )
        self:play_particle_near_light()
      end
    end,
  },
}


class "campfire_binder" ( object_binder )
function campfire_binder:__init( obj ) super( obj )
  self.initialized   = false
  self.loaded        = false
  self.flame_enabled = true
  self.state         = states.turn_off
end


function campfire_binder:reinit()
  db.storage[ self.object:id() ] = {}
  self.st = db.storage[ self.object:id() ]
end


function campfire_binder:check_npc( npc )
  if not npc then return false end
  if not npc:alive() then return false end
  local dists = { [ false ] = DIST_TO_NPC, [ true ] = DIST_TO_ACTOR }
  if self.object:position():distance_to_sqr( npc:position() ) > dists[ npc:id() == 0 ] then
    return false
  end
  if npc:id() == 0 then
    if stand_time() < 3000 then return false end
  else
    local camp_anims = {
      [ "sit"      ] = true,
      [ "sit_ass"  ] = true,
      [ "sit_knee" ] = true,
    }
    if db.storage[ npc:id() ].state_mgr then
      local anim = db.storage[ npc:id() ].state_mgr.animstate:state()
      if not camp_anims[ anim ] then return false end
    end
  end
  return true
end


function campfire_binder:find_light()
  local id = lights[ self.object:level_vertex_id() ]
  if id then
    return level.object_by_id( id )
  end
end


function campfire_binder:update( delta )
  if ( not self.initialized ) and db.actor then
    self.initialized = true
    xr_logic.initialize_obj(
      self.object, self.st, self.loaded, db.actor, modules.stype_item
    )
  end
  local time = time_global()
  if not self.scan_time then
    if not self:find_light() then return end
    self.scan_time = time
    self.state.action( self )
    self.time = time
  elseif self.scan_time < time then
    if not self:find_light() then return end
    local users = false
    for npc_id, is_npc in pairs( db.creature ) do
      if is_npc then
        local npc = level.object_by_id( npc_id )
        if self:check_npc( npc ) then
          users = true
          break
        end
      end
    end
    local new_state = self.state.next( users, time, self.time )
    ASSERT( new_state ~= nil, "new_state ~= nil" )
    if new_state ~= self.state then
      new_state.action( self )
      self.state = new_state
      self.time  = time
    end
    self.scan_time = time + SCAN_TIME
  end
end


function campfire_binder:net_spawn( data )
  if not object_binder.net_spawn( self, data ) then
    return false
  end
  flames[ self.object:id() ] = self
  return true
end


function campfire_binder:net_destroy()
  local st = db.storage[ self.object:id() ]
  if st.active_scheme then
    xr_logic.issue_event( self.object, st[ st.active_scheme ], "net_destroy" )
  end
  self:stop_idle()
  flames[ self.object:id() ] = nil
  object_binder.net_destroy( self )
end


function campfire_binder:net_save_relevant()
  return true
end


function campfire_binder:save( packet )
  object_binder.save( self, packet )
  xr_logic.save_obj( self.object, packet, not self.initialized )
  local state_name = nil
  for k,v in pairs( states ) do
    if v == self.state then state_name = k end
  end
  ASSERT( state_name ~= nil, "state_name ~= nil" )
  packet:w_stringZ( state_name )
end


function campfire_binder:load( reader )
  self.loaded = true
  object_binder.load( self, reader )
  xr_logic.load_obj( self.object, reader )
  if reader:r_eof() then return end
  self.state = states[ reader:r_stringZ() ]
  if not self.state then
    self.state = states.turn_off
  end
  ASSERT( self.state ~= nil, "self.state ~= nil" )
end


function campfire_binder:switch_light( ena )
  local light = self:find_light()
  if not light then return end
  local lamp = light:get_hanging_lamp()
  if not lamp then return end
  if ena then
    lamp:turn_on()
  else
    lamp:turn_off()
  end
end


function campfire_binder:switch_flame( ena )
  local flame = self.object
  if ena then
    self:stop_idle()
    flame:enable_anomaly()
    self.flame_enabled = true
  else
    flame:disable_anomaly()
    self.flame_enabled = false
    self:start_idle()
  end
end


function campfire_binder:start_idle()
  self.idle_t = dsh.wait_condition(
    function() return false end,
    function() end,
    function()
      ogse_signals.get_mgr():reschedule( SCAN_TIME )
      self:update()
    end
  )
end


function campfire_binder:stop_idle()
  if self.idle_t then
    self.idle_t:stop()
    self.idle_t = nil
  end
end


function campfire_binder:play_particle_near_light( particle )
  self.particle:play_at_pos( self.object:position() )
end
