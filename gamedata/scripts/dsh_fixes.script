-- -*- mode: lua; coding: windows-1251-dos -*-

function attach( sm )
  sm:subscribe({ signal = "on_before_first_update", fun = this.on_first_update })
end


local vname = "dsh_fixes.version"

function on_first_update()
  local fixes = {
    this.kill_journalist_npc,
    this.free_bar_visitors,

    this.free_bar_visitors_fix2,
    this.free_bar_ohotnik,
    this.free_kalmyak_marsh,
    this.free_marsh_exit_nebo,
    this.free_marsh_hunters,
  }
  local version = ogse.load_var( vname, 0 )
  if version < table.getn( fixes ) then
    for i = 1, table.getn( fixes ) do
      fixes[ i ]( version )
    end
    ogse.save_var( vname, table.getn( fixes ), "u32" )
  end
end


-- Сделать труп журналиста, который случайно заспаунился живым
function kill_journalist_npc()
  local sobj = alife():story_object( story_ids.journalist_npc )
  if sobj then
    local obj = level.object_by_id( sobj.id )
    if obj then
      obj:kill( obj )
    else
      ogse.kill_offline_npc( sobj )
    end
  end
end

function free_smart_terrain( name, skip_npc )
  local skip_npc_keys = {}
  if skip_npc then
    for _, v in ipairs( skip_npc ) do
      skip_npc_keys[ v ] = true
    end
  end
  local strn = smart_terrain.get_smart_terrain_by_name( name )
  for id, v in pairs( strn.npc_info ) do
    local sobj = alife():object( id )
    if not skip_npc_keys[ sobj:name() ] then
      local pk = xs_netpk.stalker( sobj )
      if pk:isOk() then
        local data = pk:get()
        local cd   = data.custom_data:getTable()
        cd.smart_terrains = nil
        data.custom_data:set( cd )
        pk:set( data )
      end
      smart_terrain.unregister_npc( sobj )
      sobj.smart_terrain_conditions = nil
    end
  end
end


-- Убрать у сталкеров жесткую привязку к смарту, что бы они могли уходить.
function free_bar_visitors()
  free_smart_terrain( "bar_visitors" );
end
function free_bar_visitors_fix2( ver )
  -- выполнять только если уже выполнялся free_bar_visitors()
  if ver == 2 then
    free_smart_terrain( "bar_visitors" );
  end
end

function free_bar_ohotnik()
  free_smart_terrain( "bar_ohotnik", { "stalker_green_zahar" } );
end

function free_kalmyak_marsh()
  free_smart_terrain( "kalmyak_marsh", { "kalmyak" } );
end

function free_marsh_exit_nebo()
  free_smart_terrain( "marsh_exit_nebo", { "dyak", "esc_saha" } );
end

function free_marsh_hunters()
  free_smart_terrain( "marsh_hunters", { "marsh_dan" } );
end


function cleanup_respawners()
  se_respawn.iterate_respawners( function( respawner )
      if respawner.parent then return end
      local ids = {}
      for _, id in ipairs( respawner.spawned_obj ) do
        table.insert( ids, id )
      end
      for _, id in ipairs( ids ) do
        local sobj = alife():object( id )
        if sobj then
          local strn_id
          if ( IsStalker( sobj ) or IsMonster( sobj ) ) and sobj.smart_terrain_id then
            strn_id = sobj:smart_terrain_id()
          else
            strn_id = 65535
          end
          if strn_id ~= 65535 then
            local strn = alife():object( strn_id )
            if strn then
              if
                not smart_terrain.is_same_level_group(
                  object_level_name( strn ),
                  object_level_name( sobj )
                )
              then
                log2(
                  "dsh: remove %s from %s: smart_terrain %s has different level group: %s and %s",
                  id, respawner:name(), strn:name(),
                  object_level_name( strn ),
                  object_level_name( sobj )
                )
                respawner:remove_spawned( id )
              end
            else
              log2(
                "dsh: remove %s from %s: smart_terrain %s not found",
                id, respawner:name(), strn_id
              )
              respawner:remove_spawned( id )
            end
          end
        else
          log2( "dsh: remove %s from %s (%s): not found", id, respawner:name(), tostring( respawner.amk_name ) )
          respawner:remove_spawned( id )
        end
      end
  end )
end


function remove_ogse_relation_reverse_table()
  ogse.delete_var( "ogse_relation_reverse_table" )
end
