-- -*- mode: lua; coding: windows-1251-dos -*-
-------------------------------------------------------------------------------
--| ogse_relations.script                                                   |--
--| Скриптовая обвязка для очистки отношений                                |--
--| K.D., OGS Evolution Team, 2015                                          |--
--| Ревизия: 14/03/2015                                                     |--
-------------------------------------------------------------------------------

function attach(sm) -- для менеджера сигналов
  sm:subscribe({ signal = "on_init", fun = this.on_actor_init })
end


local rrr
function on_actor_init()
  log1( "RRR INITING" )
  rrr = reverse_relation_register() -- создание
end


class "reverse_relation_register"
function reverse_relation_register:__init()
  self.delayed_cleanup = {}
  self.relation_seen   = {}
  self.relation_table  = {}
  self.sm = ogse_signals.get_mgr()

  self._on_goodwill_change = {
    signal = "on_goodwill_change",
    self   = self,
    fun    = self.on_goodwill_change
  }
  self.sm:subscribe( self._on_goodwill_change )

  self._on_release = {
    signal = "on_release_npc",
    self   = self,
    fun    = self.on_release
  }
  self.sm:subscribe( self._on_release )

  self._on_save = { signal = "on_save", self = self, fun = self.save }
  self.sm:subscribe( self._on_save )

  self._on_load = { signal = "on_load", self = self, fun = self.load }
  self.sm:subscribe( self._on_load )

  self._on_update = {
    signal = "on_first_update", self = self, fun = self.first_update
  }
  self.sm:subscribe( self._on_update )
end


function reverse_relation_register:on_goodwill_change( from, to )
  if to == 0 then return end
  if not self.relation_seen[ to ] then self.relation_seen[ to ] = {} end
  if self.relation_seen[ to ][ from ] then
    log1(
      "[RELATIONS] REPEATED GOODWILL CHANGED FROM "
        .. alife():object( from ):name() .. " TO " .. alife():object( to ):name()
    )
  else
    if not self.relation_table[ to ] then
      self.relation_table[ to ] = {}
    end
    table.insert( self.relation_table[ to ], from )
    self.relation_seen[ to ][ from ] = true
    log1(
      "[RELATIONS] GOODWILL CHANGED FROM "
        .. alife():object( from ):name() .. " TO " .. alife():object( to ):name()
    )
  end
end


function reverse_relation_register:on_release( npc_id )
  if npc_id == 0 then return end
  log2( "[RELATIONS] NPC %s RELEASED", tostring( npc_id ) )
  local from_table = self.relation_table[ npc_id ]
  if from_table then
    if db.actor then
      self:clear_personal_records( npc_id )
    else
      log1( "[RELATIONS] db.actor not found" )
      self.delayed_cleanup[ npc_id ] = true
    end
  end
end


function reverse_relation_register:clear_personal_records( npc_id )
  local from_table = self.relation_table[ npc_id ]
  for _, id in ipairs( from_table ) do
    db.actor:clear_personal_record( id, npc_id )
    local sobj = alife():object( id )
    if sobj then
      log1(
        "[RELATIONS] RELATION RECORD CLEARED FOR OBJECT " .. sobj:name()
      )
    else
      log1(
        "[RELATIONS] RELATION RECORD CLEARED FOR OBJECT WITH ID " .. id
      )
    end
  end
  self.relation_seen[ npc_id ] = nil
  self.relation_table[ npc_id ] = nil
end


function reverse_relation_register:save()
  local pk = net_packet()
  pk:w_begin( 123 ) -- двухбайтовая заглушка
  pk:r_seek( 2 )    -- чтобы пропустить эти два байта при чтении
  local rel_table_size = 0
  for k, v in pairs( self.relation_table ) do
    rel_table_size = rel_table_size + 1
  end
  pk:w_u16( rel_table_size )
  log1( "[RELATIONS] RELATION TABLE SIZE IS " .. tostring( rel_table_size ) )
  for k, v in pairs( self.relation_table ) do
    local table_size = table.getn( v )
    log1(
      "[RELATIONS] SAVING RELATION TABLE RECORD "
        .. tostring( k ) .. " WITH SIZE " .. tostring( table_size )
    )
    if k == "actor" then
      pk:w_u16( 0 )
    else
      pk:w_u16( k )
    end
    pk:w_u16( table_size )
    for _, id in ipairs( v ) do
      pk:w_u16( id )
      log1(
        "[RELATIONS] SAVING RELATION TO "
          .. tostring( k ) .. " FROM " .. tostring( id )
      )
    end
  end
  log1(
    "[RELATIONS] RELATION TABLE SAVED! Packet length = "
      .. tostring( pk:w_tell() )
  )
  ogse.save_var( "dsh_ogse_relations", pk, "chunk" )
end


function reverse_relation_register:load()
  local pk = ogse.load_var_safe( "dsh_ogse_relations" )
  if pk then
    local table_size = pk:r_u16()
    log1( "[RELATIONS] RELATION TABLE SIZE IS ".. tostring( table_size ) )
    for i = 1, table_size do
      local to_id   = pk:r_u16()
      local to_size = pk:r_u16()
      log1(
        "[RELATIONS] LOADING RELATION TABLE RECORD "
          .. tostring( to_id ) .. " WITH SIZE " .. tostring( to_size )
      )
      if to_id == 0 then
        to_id = "actor"
      end
      self.relation_seen[ to_id ] = {}
      self.relation_table[ to_id ] = {}
      for j = 1, to_size do
        local curr_id = pk:r_u16()
        ASSERT(
          ( not self.relation_seen[ to_id ][ curr_id ] ),
          "[RELATIONS] FOUND SECOND RECORD TO %s FROM %s",
          tostring( to_id ), tostring( curr_id )
        )
        table.insert( self.relation_table[ to_id ], curr_id )
        self.relation_seen[ to_id ][ curr_id ] = true
        log1(
          "[RELATIONS] LOADING RELATION TO "
            .. tostring( to_id ) .. " FROM " .. tostring( curr_id )
        )
      end
    end
    log1( "[RELATIONS] RELATION TABLE LOADED!" )
  end
end


function reverse_relation_register:first_update()
  for npc_id, _ in pairs( self.delayed_cleanup ) do
    log2( "[RELATIONS] DELAYED CLEANUP FOR NPC %s", tostring( npc_id ) )
    self:clear_personal_records( npc_id )
  end
  self.delayed_cleanup = {}
end
