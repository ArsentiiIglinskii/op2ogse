--[[ -*- mode: lua; coding: windows-1251-dos -*-


Этот скрипт эмулирует поглощение энергии хита артефактами, размещенными на поясе.
Каждый артефакт, находящийся под контролем скрипта, способен поглотить
определенное кол-во энергии, после чего, он преобразуется в булыжник.

Дополнительно, эмулируется пулезащита брони.

]]

local our_hits = {              -- какие типы хита будут обрабатываться
  [ hit.explosion ] = {
    [ "max"  ] = 10,           -- порог поглощения
    [ "sect" ] = "explosion_immunity",
  },
  [ hit.fire_wound ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "fire_wound_immunity",
    [ "ignored_outfit_protection" ] = true,
  },
  [ hit.strike ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "strike_immunity",
  },
  [ hit.wound ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "wound_immunity",
  },
  [ hit.burn ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "burn_immunity",
  },
  [ hit.chemical_burn ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "chemical_burn_immunity",
  },
  [ hit.shock ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "shock_immunity",
  },
  [ hit.radiation ] = {
    [ "max"  ] = 100,
    [ "sect" ] = "radiation_immunity",
  },
  [ hit.telepatic ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "telepatic_immunity",
  },
  [ "bleeding" ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "bleeding_restore_speed",
  },
  [ "health" ] = {
    [ "max"  ] = 10,
    [ "sect" ] = "health_restore_speed",
  },
  [ "radiation" ] = {
    [ "max"  ] = 1,
    [ "sect" ] = "radiation_restore_speed",
  },
}


local sm_attached
function attach( sm )
  if not ui_mm_opt_main.GetOption( "art_degradation" ) then return end
  sm_attached = {
    { signal = "on_actor_before_hit",  fun = this.before_hit },
    { signal = "on_update",            fun = this.on_update, queued = true  },
  }
  for _, v in ipairs( sm_attached ) do
    sm:subscribe( v )
  end
end
function detach( sm )
  for _, v in ipairs( sm_attached ) do
    sm:unsubscribe( v )
  end
  got_hits = {}
  has_hit  = false
end


local got_hits = {}
local has_hit  = false
function before_hit( hit_data, p_s_hit, p_ignore_flags )
  local hit_type = hit_data.hit_type
  local our_hit  = our_hits[ hit_type ]
  if our_hit and hit_data.power > 0 then
    local real_power = calc_real_hit_power( our_hit, hit_data )
    if real_power > 0 then
      if got_hits[ hit_type ] then
        got_hits[ hit_type ] = got_hits[ hit_type ] + real_power
      else
        got_hits[ hit_type ] = real_power
      end
      has_hit = true
    end
    if our_hit.ignored_outfit_protection then
      apply_outfit_protection( hit_data, p_s_hit )
    end
  end
end


function apply_outfit_protection( hit_data, p_s_hit )
  if db.actor and db.actor:alive() then
    local outfit_item = db.actor:item_in_slot( 6 )
    if outfit_item then
      local koef    = hit_data.power / 5
      if     koef < 0.1 then
        koef = 0.1
      elseif koef > 1 then
        koef = 1
      end
      local imm_val = db.actor:get_current_outfit_protection(
        hit_data.hit_type
      ) * koef
      if imm_val > 0 then
        write_memory_float(
          hit_data.power * ( 1 - imm_val ),
          p_s_hit,
          hit_offset.power
        )
      end
    end
  end
end


function calc_real_hit_power( our_hit, hit_data )
  local hit_power = hit_data.power
  -- вычислить хит до его поглощения артефактами
  local hit_immunity = inventory.on_belt_hit_immunity( our_hit.sect )
  if hit_immunity > 0 then
    hit_power = hit_power / ( 1 - hit_immunity )
  end
  return hit_power
end


local absorbations   = {}
local need_addl_keys = {
  [ "bleeding_restore_speed"  ] =  1,
  [ "health_restore_speed"    ] =  1,
  [ "radiation_restore_speed" ] = -1,
}
function get_absorbations( af )
  local af_sect = af:section()
  if not absorbations[ af_sect ] then
    local absorb_sect = get_string( af_sect, "hit_absorbation_sect" )
    if absorb_sect then
      if not absorbations[ af_sect ] then
        absorbations[ af_sect ] = {}
        for _, k in ipairs( get_section_keys( absorb_sect ) ) do
          local absorb_val = 1 - get_float( absorb_sect, k, 1 )
          if absorb_val > 0 then
            absorbations[ af_sect ][ k ] = absorb_val
          end
        end
      end
    end
    for k, v in pairs( need_addl_keys ) do
      local val = get_float( af_sect, k, 0 )
      if     v > 0 and val > 0 then
        absorbations[ af_sect ][ k ] = val
      elseif v < 0 and val < 0 then
        absorbations[ af_sect ][ k ] = math.abs( val )
      end
    end
  end
  return absorbations[ af_sect ]
end


local last_t = 0
function on_update()
  local bleeding = db.actor:get_bleeding()
  if bleeding > 0 then
    local hit_type = "bleeding"
    if got_hits[ hit_type ] then
      got_hits[ hit_type ] = got_hits[ hit_type ] + bleeding
    else
      got_hits[ hit_type ] = bleeding
    end
    has_hit = true
  end
  local health = db.actor.health
  if health < 1 then
    local hit_type = "health"
    local val      = 1 - health
    if got_hits[ hit_type ] then
      got_hits[ hit_type ] = got_hits[ hit_type ] + val
    else
      got_hits[ hit_type ] = val
    end
    has_hit = true
  end
  if has_hit and time_global() - last_t >= 1000 then
    local empty = {}
    local master_coef = 4 - level.get_game_difficulty()
    got_hits[ "radiation" ] = got_hits[ hit.radiation ];
    for i = 0, db.actor:belt_count() - 1 do
      local af = db.actor:item_on_belt( i )
      if af:is_artefact() then
        local af_sect = af:section()
        local absorbs = get_absorbations( af )
        if absorbs then
          local cond_diff = 0
          for hit_type, hit_power in pairs( got_hits ) do
            local our_hit = our_hits[ hit_type ]
            if absorbs[ our_hit.sect ] then
              local absorb_val = absorbs[ our_hit.sect ] * hit_power
              cond_diff = cond_diff + (
                absorb_val / ( our_hit.max * master_coef )
              )
            end
          end
          if cond_diff > 0 then
            if af:condition() > cond_diff then
              dsh.set_condition( af, af:condition() - cond_diff )
            else
              table.insert( empty, af )
            end
          end
        end
      end
    end
    for _, af in ipairs( empty ) do
      ogse.remove_item_from_inventory( af )
      inventory.forced_inventory_update( false )
      ogse.spawn_item_in_inv( "af_buliz" )
    end
    for hit_type, hit_power in pairs( got_hits ) do
      got_hits[ hit_type ] = 0
    end
    has_hit = false
    last_t  = time_global()
  end
end
